{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome Imposter is a reliable, scriptable and extensible mock server for REST APIs, OpenAPI (and Swagger) specifications, Salesforce and HBase APIs. Run standalone mock servers, or embed mocks within your tests (supports JVM and Node.js). Dynamic responses can be scripted using JavaScript, Groovy or Java. Getting started To begin, check out the Getting started guide. See the User documentation section below, or learn more about features . User documentation Configuration guide Usage (arguments and environment variables) Scripting Security Data capture, storage and templates Data capture Response templates Stores Advanced Advanced request matching OpenAPI validation Performance simulation Metrics, logs and telemetry Performance tuning Other Tips and tricks Benchmarks Plugins Imposter uses plugins to control its behaviour and provide specialised mocks. Learn about plugins and features . The following sections describe the built-in plugins. OpenAPI (and Swagger) plugin REST plugin HBase plugin SFDC (Salesforce) plugin Developers Build Roadmap Tutorials Mocking APIs with Swagger and Imposter Mocking REST APIs with Imposter","title":"Introduction"},{"location":"#welcome","text":"Imposter is a reliable, scriptable and extensible mock server for REST APIs, OpenAPI (and Swagger) specifications, Salesforce and HBase APIs. Run standalone mock servers, or embed mocks within your tests (supports JVM and Node.js). Dynamic responses can be scripted using JavaScript, Groovy or Java.","title":"Welcome"},{"location":"#getting-started","text":"To begin, check out the Getting started guide. See the User documentation section below, or learn more about features .","title":"Getting started"},{"location":"#user-documentation","text":"Configuration guide Usage (arguments and environment variables) Scripting Security","title":"User documentation"},{"location":"#data-capture-storage-and-templates","text":"Data capture Response templates Stores","title":"Data capture, storage and templates"},{"location":"#advanced","text":"Advanced request matching OpenAPI validation Performance simulation Metrics, logs and telemetry Performance tuning","title":"Advanced"},{"location":"#other","text":"Tips and tricks Benchmarks","title":"Other"},{"location":"#plugins","text":"Imposter uses plugins to control its behaviour and provide specialised mocks. Learn about plugins and features . The following sections describe the built-in plugins. OpenAPI (and Swagger) plugin REST plugin HBase plugin SFDC (Salesforce) plugin","title":"Plugins"},{"location":"#developers","text":"Build Roadmap","title":"Developers"},{"location":"#tutorials","text":"Mocking APIs with Swagger and Imposter Mocking REST APIs with Imposter","title":"Tutorials"},{"location":"benchmarks/","text":"Performance benchmarks Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint. This section provides representative performance tests, including test set up and configuration. See Performance tuning to learn how to get the most out of Imposter. Benchmarks Test configuration: 1 CPU core 256MB RAM Load injector: Apache Bench 2.3 See Benchmark set up section for full details. Warm-up 5 x 2 second load, at concurrency of 50 Scenario 1: Static, configuration-driven Threads Requests/sec HTTP Keep-alive 50 1099 Disabled 100 1330 Disabled 200 1438 Disabled 200 1904 Enabled Scenario 2: Conditional, configuration-driven Threads Requests/sec HTTP Keep-alive 50 901 Disabled 100 1159 Disabled 200 1416 Disabled 200 1855 Enabled Scenario 3: Dynamic, script-driven Threads Requests/sec HTTP Keep-alive 50 3364 Disabled 100 3590 Disabled 200 3710 Disabled 200 7236 Enabled Benchmark set up Configuration and commands to allow benchmarks to be independently reproduced. Scenarios Scenario 1: Static, configuration-driven: examples/rest/simple Scenario 2: Conditional, configuration-driven: examples/rest/conditional-config Scenario 3: Dynamic, script-driven: examples/rest/conditional-scripted Start command docker run --rm -it -v /path/to/config:/opt/imposter/config -p 8080:8080 --cpus=1 --memory=256m outofcoffee/imposter:1.23.3 Notes: limits to 1 CPU core limits to 256 MB RAM Warmup command for i in {1..5}; do ab -t 2 -c 50 http://localhost:8080/example ; sleep 5 ; done Notes: actual URL depends on the scenario (see above) Benchmark command ab -n 2000 -c 200 http://localhost:8080/example Notes: actual URL depends on the scenario (see above) concurrency value ( -c flag) depends on test case (see above)","title":"Benchmarks"},{"location":"benchmarks/#performance-benchmarks","text":"Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint. This section provides representative performance tests, including test set up and configuration. See Performance tuning to learn how to get the most out of Imposter.","title":"Performance benchmarks"},{"location":"benchmarks/#benchmarks","text":"Test configuration: 1 CPU core 256MB RAM Load injector: Apache Bench 2.3 See Benchmark set up section for full details.","title":"Benchmarks"},{"location":"benchmarks/#warm-up","text":"5 x 2 second load, at concurrency of 50","title":"Warm-up"},{"location":"benchmarks/#scenario-1-static-configuration-driven","text":"Threads Requests/sec HTTP Keep-alive 50 1099 Disabled 100 1330 Disabled 200 1438 Disabled 200 1904 Enabled","title":"Scenario 1: Static, configuration-driven"},{"location":"benchmarks/#scenario-2-conditional-configuration-driven","text":"Threads Requests/sec HTTP Keep-alive 50 901 Disabled 100 1159 Disabled 200 1416 Disabled 200 1855 Enabled","title":"Scenario 2: Conditional, configuration-driven"},{"location":"benchmarks/#scenario-3-dynamic-script-driven","text":"Threads Requests/sec HTTP Keep-alive 50 3364 Disabled 100 3590 Disabled 200 3710 Disabled 200 7236 Enabled","title":"Scenario 3: Dynamic, script-driven"},{"location":"benchmarks/#benchmark-set-up","text":"Configuration and commands to allow benchmarks to be independently reproduced.","title":"Benchmark set up"},{"location":"benchmarks/#scenarios","text":"Scenario 1: Static, configuration-driven: examples/rest/simple Scenario 2: Conditional, configuration-driven: examples/rest/conditional-config Scenario 3: Dynamic, script-driven: examples/rest/conditional-scripted","title":"Scenarios"},{"location":"benchmarks/#start-command","text":"docker run --rm -it -v /path/to/config:/opt/imposter/config -p 8080:8080 --cpus=1 --memory=256m outofcoffee/imposter:1.23.3 Notes: limits to 1 CPU core limits to 256 MB RAM","title":"Start command"},{"location":"benchmarks/#warmup-command","text":"for i in {1..5}; do ab -t 2 -c 50 http://localhost:8080/example ; sleep 5 ; done Notes: actual URL depends on the scenario (see above)","title":"Warmup command"},{"location":"benchmarks/#benchmark-command","text":"ab -n 2000 -c 200 http://localhost:8080/example Notes: actual URL depends on the scenario (see above) concurrency value ( -c flag) depends on test case (see above)","title":"Benchmark command"},{"location":"build/","text":"Build Hacking locally You can build and run locally using the dev-current.sh convenience script. This will start Imposter in debug mode, with the debug port running on 8000. Build and run with Docker: ./scripts/dev-current.sh -m docker Build and run with local JVM: ./scripts/dev-current.sh -m java More complete example specifying plugin and config directory: ./scripts/dev-current.sh -m docker -p rest -c $PWD/docs/examples/rest/multiple See the README for more details about using this script. Local build If you don't want to use the convenience script, then you can follow these steps. Prerequisites JDK 8 Steps For distribution, Imposter is built as an all-in-one JAR file. This is available as a Docker image, as well as in raw form. To get started with the examples here, first run: ./gradlew clean shadowJar The JAR is created under the distro/all/build/libs directory. If, instead, you wanted to compile the JAR without embedded dependencies, use: ./gradlew clean build Tests If you want to run tests: ./gradlew clean test Docker containers Build the Docker containers with: ./scripts/docker-build.sh Extending to build a custom application To extend Imposter and build a custom application see this section .","title":"Build"},{"location":"build/#build","text":"","title":"Build"},{"location":"build/#hacking-locally","text":"You can build and run locally using the dev-current.sh convenience script. This will start Imposter in debug mode, with the debug port running on 8000. Build and run with Docker: ./scripts/dev-current.sh -m docker Build and run with local JVM: ./scripts/dev-current.sh -m java More complete example specifying plugin and config directory: ./scripts/dev-current.sh -m docker -p rest -c $PWD/docs/examples/rest/multiple See the README for more details about using this script.","title":"Hacking locally"},{"location":"build/#local-build","text":"If you don't want to use the convenience script, then you can follow these steps.","title":"Local build"},{"location":"build/#prerequisites","text":"JDK 8","title":"Prerequisites"},{"location":"build/#steps","text":"For distribution, Imposter is built as an all-in-one JAR file. This is available as a Docker image, as well as in raw form. To get started with the examples here, first run: ./gradlew clean shadowJar The JAR is created under the distro/all/build/libs directory. If, instead, you wanted to compile the JAR without embedded dependencies, use: ./gradlew clean build","title":"Steps"},{"location":"build/#tests","text":"If you want to run tests: ./gradlew clean test","title":"Tests"},{"location":"build/#docker-containers","text":"Build the Docker containers with: ./scripts/docker-build.sh","title":"Docker containers"},{"location":"build/#extending-to-build-a-custom-application","text":"To extend Imposter and build a custom application see this section .","title":"Extending to build a custom application"},{"location":"configuration/","text":"Configuration guide Read this section to learn how to configure Imposter. Basics Imposter configuration files are in YAML or JSON format. They must be named with a -config.yaml or -config.json suffix. For example: mymock-config.yaml . Here is an example configuration file: # simple-example-config.yaml --- plugin: rest path: \"/example\" response: staticFile: example-data.json Or, in JSON format: { \"plugin\": \"rest\", \"path\": \"/example\", \"response\": { \"staticFile\": \"example-data.json\" } } Note: You must specify the plugin to use in the configuration file. See the list of plugins for possible values. Returning data You can control the data Imposter sends back using response files. The response file is used by the active plugin to generate a response. For example, the REST plugin might return the content of the file unmodified, whereas the HBase and SFDC plugins use the response file to generate responses that mimic their respective systems. Response files can be named anything you like; their path is resolved relative to the configuration file. Simple, static responses For simple scenarios, use the staticFile property within the response object in your configuration. In the example above, we are using a static response file ( example-data.json ) containing the following: { \"hello\": \"world\" } Using the configuration above, if we were to send an HTTP request to the /example path defined in the configuration file, we would see: HTTP GET http://localhost:8080/example ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } The plugin has returned the contents of the staticFile in the HTTP response. Your response files can also be templated - that is, contain placeholders for substituted at runtime. See templates for more information. Response configuration options You can specify other properties of the response, such as status code and headers. Here is a more complete example: Single resource example # single-response-config.yaml --- plugin: rest path: \"/example\" method: POST contentType: \"application/json\" response: staticFile: data.json statusCode: 201 headers: X-Custom-Header: foo A few things to call out: This endpoint will only be accessible via the POST HTTP method We've indicated that status code 201 should be returned We've set the content type of the response to JSON A custom header will be returned Multiple resources example The OpenAPI plugin and REST plugin allow you to specify multiple resources, using the resources array. Each resource can have its own path, method, response behaviour etc. # multi-response-config.yaml --- plugin: rest resources: - path: \"/example1\" contentType: \"application/json\" method: GET response: staticFile: data1.json statusCode: 200 headers: X-Custom-Header: foo - path: \"/example2\" contentType: \"text/plain\" method: POST response: statusCode: 201 headers: X-Custom-Header: bar staticData: | This is some multiline response data. Default response configuration In some cases, you might want to define default response configuration, e.g. a header that should be sent in all responses. To do this, set the defaultsFromRootResponse: true option, as follows: plugin: rest # root response config should be inherited defaultsFromRootResponse: true response: headers: X-Always-Present: Yes resources: - method: GET path: /example1 response: staticData: \"Hello world\" - method: GET path: /example2 response: staticData: \"Lorem ipsum\" In this example, responses to both /example1 and /example2 will have the header X-Always-Present: Yes set, as it is inherited from the root configuration. See default-response-config for an example. Default response values If unset by configuration or a script, the default values for response configuration fields are as follows: Field Plugin(s) Type Default Example contentType all String application/json , or determined from static file text/plain response.statusCode openapi, rest Integer (HTTP status) 200 201 response.staticData openapi, rest String empty hello world response.staticFile all String empty data.json response.headers openapi, rest Map of String:String empty { \"X-Custom-Header\": \"value\" } Conditional responses You can make Imposter respond with different values based on certain properties of the request in your configuration file, or using the script engine. For information about the script engine, see the Scripting documentation. Configure different response behaviours based on the following request attributes: Field Plugin(s) Type Example path all String /example/path method openapi, rest String (HTTP method) POST pathParams openapi, rest Map of String:String { \"productCode\": \"abc\" } queryParams openapi, rest Map of String:String { \"limit\": \"10\" } requestHeaders openapi, rest Map of String:String { \"User-Agent\": \"curl\" } requestBody openapi, rest Request body matching configuration See advanced matching Here is an example showing all fields: plugin: openapi specFile: apispec.yaml resources: # handles GET /pets?page=1 - path: \"/pets\" method: GET queryParams: page: 1 response: statusCode: 200 # handles GET /pets/10 - path: \"/pets/:petId\" method: GET pathParams: petId: 10 response: statusCode: 401 staticData: \"You do not have permission to view this pet.\" # handles PUT /pets/:petId with a request header 'X-Pet-Username: foo' - path: \"/pets/:petId\" method: PUT requestHeaders: X-Pet-Username: foo response: statusCode: 409 staticData: \"Username already exists.\" Capturing data Imposter allows you to capture elements of the request. You can use these elements in a response template , a script or add them to a store for later use. See data capture for more information. Environment variables You can use environment variables as placeholders in plugin configuration files. # A plugin configuration using an environment variable. --- plugin: rest path: /example response: staticData: \"${env.EXAMPLE_RESPONSE}\" Here the environment variable EXAMPLE_RESPONSE will be substituted into the configuration. For example, if the variable was set as follows: EXAMPLE_RESPONSE=\"Hello\" ...then the static data Hello will be returned. You can use environment variables anywhere within your configuration files, for example, in the security section to avoid including secrets in your configuration files. Security Imposter can require specific header values to authenticate incoming HTTP requests. Read about how to do this . Scripted responses (advanced) For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information. Resource matching performance Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.","title":"Configuration guide"},{"location":"configuration/#configuration-guide","text":"Read this section to learn how to configure Imposter.","title":"Configuration guide"},{"location":"configuration/#basics","text":"Imposter configuration files are in YAML or JSON format. They must be named with a -config.yaml or -config.json suffix. For example: mymock-config.yaml . Here is an example configuration file: # simple-example-config.yaml --- plugin: rest path: \"/example\" response: staticFile: example-data.json Or, in JSON format: { \"plugin\": \"rest\", \"path\": \"/example\", \"response\": { \"staticFile\": \"example-data.json\" } } Note: You must specify the plugin to use in the configuration file. See the list of plugins for possible values.","title":"Basics"},{"location":"configuration/#returning-data","text":"You can control the data Imposter sends back using response files. The response file is used by the active plugin to generate a response. For example, the REST plugin might return the content of the file unmodified, whereas the HBase and SFDC plugins use the response file to generate responses that mimic their respective systems. Response files can be named anything you like; their path is resolved relative to the configuration file.","title":"Returning data"},{"location":"configuration/#simple-static-responses","text":"For simple scenarios, use the staticFile property within the response object in your configuration. In the example above, we are using a static response file ( example-data.json ) containing the following: { \"hello\": \"world\" } Using the configuration above, if we were to send an HTTP request to the /example path defined in the configuration file, we would see: HTTP GET http://localhost:8080/example ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } The plugin has returned the contents of the staticFile in the HTTP response. Your response files can also be templated - that is, contain placeholders for substituted at runtime. See templates for more information.","title":"Simple, static responses"},{"location":"configuration/#response-configuration-options","text":"You can specify other properties of the response, such as status code and headers. Here is a more complete example:","title":"Response configuration options"},{"location":"configuration/#single-resource-example","text":"# single-response-config.yaml --- plugin: rest path: \"/example\" method: POST contentType: \"application/json\" response: staticFile: data.json statusCode: 201 headers: X-Custom-Header: foo A few things to call out: This endpoint will only be accessible via the POST HTTP method We've indicated that status code 201 should be returned We've set the content type of the response to JSON A custom header will be returned","title":"Single resource example"},{"location":"configuration/#multiple-resources-example","text":"The OpenAPI plugin and REST plugin allow you to specify multiple resources, using the resources array. Each resource can have its own path, method, response behaviour etc. # multi-response-config.yaml --- plugin: rest resources: - path: \"/example1\" contentType: \"application/json\" method: GET response: staticFile: data1.json statusCode: 200 headers: X-Custom-Header: foo - path: \"/example2\" contentType: \"text/plain\" method: POST response: statusCode: 201 headers: X-Custom-Header: bar staticData: | This is some multiline response data.","title":"Multiple resources example"},{"location":"configuration/#default-response-configuration","text":"In some cases, you might want to define default response configuration, e.g. a header that should be sent in all responses. To do this, set the defaultsFromRootResponse: true option, as follows: plugin: rest # root response config should be inherited defaultsFromRootResponse: true response: headers: X-Always-Present: Yes resources: - method: GET path: /example1 response: staticData: \"Hello world\" - method: GET path: /example2 response: staticData: \"Lorem ipsum\" In this example, responses to both /example1 and /example2 will have the header X-Always-Present: Yes set, as it is inherited from the root configuration. See default-response-config for an example.","title":"Default response configuration"},{"location":"configuration/#default-response-values","text":"If unset by configuration or a script, the default values for response configuration fields are as follows: Field Plugin(s) Type Default Example contentType all String application/json , or determined from static file text/plain response.statusCode openapi, rest Integer (HTTP status) 200 201 response.staticData openapi, rest String empty hello world response.staticFile all String empty data.json response.headers openapi, rest Map of String:String empty { \"X-Custom-Header\": \"value\" }","title":"Default response values"},{"location":"configuration/#conditional-responses","text":"You can make Imposter respond with different values based on certain properties of the request in your configuration file, or using the script engine. For information about the script engine, see the Scripting documentation. Configure different response behaviours based on the following request attributes: Field Plugin(s) Type Example path all String /example/path method openapi, rest String (HTTP method) POST pathParams openapi, rest Map of String:String { \"productCode\": \"abc\" } queryParams openapi, rest Map of String:String { \"limit\": \"10\" } requestHeaders openapi, rest Map of String:String { \"User-Agent\": \"curl\" } requestBody openapi, rest Request body matching configuration See advanced matching Here is an example showing all fields: plugin: openapi specFile: apispec.yaml resources: # handles GET /pets?page=1 - path: \"/pets\" method: GET queryParams: page: 1 response: statusCode: 200 # handles GET /pets/10 - path: \"/pets/:petId\" method: GET pathParams: petId: 10 response: statusCode: 401 staticData: \"You do not have permission to view this pet.\" # handles PUT /pets/:petId with a request header 'X-Pet-Username: foo' - path: \"/pets/:petId\" method: PUT requestHeaders: X-Pet-Username: foo response: statusCode: 409 staticData: \"Username already exists.\"","title":"Conditional responses"},{"location":"configuration/#capturing-data","text":"Imposter allows you to capture elements of the request. You can use these elements in a response template , a script or add them to a store for later use. See data capture for more information.","title":"Capturing data"},{"location":"configuration/#environment-variables","text":"You can use environment variables as placeholders in plugin configuration files. # A plugin configuration using an environment variable. --- plugin: rest path: /example response: staticData: \"${env.EXAMPLE_RESPONSE}\" Here the environment variable EXAMPLE_RESPONSE will be substituted into the configuration. For example, if the variable was set as follows: EXAMPLE_RESPONSE=\"Hello\" ...then the static data Hello will be returned. You can use environment variables anywhere within your configuration files, for example, in the security section to avoid including secrets in your configuration files.","title":"Environment variables"},{"location":"configuration/#security","text":"Imposter can require specific header values to authenticate incoming HTTP requests. Read about how to do this .","title":"Security"},{"location":"configuration/#scripted-responses-advanced","text":"For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information.","title":"Scripted responses (advanced)"},{"location":"configuration/#resource-matching-performance","text":"Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.","title":"Resource matching performance"},{"location":"data_capture/","text":"Capturing request data Imposter allows you to capture elements of the request. You can use these elements in a response template , a script or add them to a store for later use. It is possible to capture the following elements into a store: path parameter query parameter request header part or all of the request body (using JsonPath expression) Capture example Use the capture block of a resource, as follows: resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: testStore In this example, the value of the path parameter 'userName' is added to the store named 'testStore' as an item named 'user'. For example, the following request: PUT /users/alice ...would result in the 'testStore' store containing the item 'user' with the value 'alice'. Note that the name of the item is the object key - in the above example it is user . Multiple items can be captured from the same request using different keys: resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: testStore agent: requestHeader: User-Agent store: testStore Capture configuration The following configuration options are available for a capture: Element Purpose capture block key The name of the item to capture, e.g. user . store The name of the store in which to put the item. pathParam The name of the path parameter to capture. Must reference the resource path, e.g. userId for a path of /users/:userId queryParam The name of the query parameter to capture. requestHeader The name of the request header to capture. jsonPath The JsonPath expression to query the JSON body. Only works with JSON request bodies. Request scoped store There is a special request-scoped store, named request , which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request. The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template, but you don't need to persist it for later use. Here is an example combining capture and response template: Learn more about response templates . # part of your configuration file resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: request response: staticFile: example-template.json template: true Here is the corresponding template file: { \"userName\": \"${request.user}\" } If you were to make the following request: curl -X PUT http://localhost:8080/users/alice ...you would receive the following response: { \"userName\": \"alice\" } Capturing the request body You can capture part or all of the request body using a JsonPath expression. For example, if the request body was: { \"name\": \"Alice\", \"address\": { \"street\": \"1 Main Street\", \"postCode\": \"PO5 7CO\" } } ...you could capture the name as follows: # part of your configuration file resources: - path: \"/users\" method: POST capture: firstName: jsonPath: $.name store: testStore In this example, the name property of the body would be stored in the 'firstName' item in the store named 'testStore'. Constant values In some scenarios, you may wish to capture a constant value. Example: plugin: rest - method: GET path: /test capture: # constant value receivedRequest: store: example const: yes response: statusCode: 200 In the example above, the value yes is stored in the 'example' store, with the name 'receivedRequest', when the given endpoint is hit. Capturing an object In some scenarios you may wish to capture an object instead of a single value. For example, to capture the address from the example above, use the JsonPath expression $.address - this will result in the entire address object being captured. You can retrieve this object in a script, by accessing the store named 'testStore', or you could use it in a JsonPath placeholder within a template . Dynamic item names You do not have to specify a constant value for the item name - you can use a property of the request, such as a query or path parameter, header or body element as the item name. Dynamic item names are useful when you want to capture collections of items, each with their own name derived from the request. Example: plugin: rest - method: PUT path: /users/admins/:userId capture: # constant value, but dynamic key adminUser: key: pathParam: userId store: adminUsers const: admin response: statusCode: 200 In the example above, an item corresponding to the userId parameter in the request is added to the 'adminUsers' store with the constant value admin . Note: Values do not have to be constant - you can combine dynamic item names and captured data. Capture performance Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data. Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference. Examples data-capture","title":"Data capture"},{"location":"data_capture/#capturing-request-data","text":"Imposter allows you to capture elements of the request. You can use these elements in a response template , a script or add them to a store for later use. It is possible to capture the following elements into a store: path parameter query parameter request header part or all of the request body (using JsonPath expression)","title":"Capturing request data"},{"location":"data_capture/#capture-example","text":"Use the capture block of a resource, as follows: resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: testStore In this example, the value of the path parameter 'userName' is added to the store named 'testStore' as an item named 'user'. For example, the following request: PUT /users/alice ...would result in the 'testStore' store containing the item 'user' with the value 'alice'. Note that the name of the item is the object key - in the above example it is user . Multiple items can be captured from the same request using different keys: resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: testStore agent: requestHeader: User-Agent store: testStore","title":"Capture example"},{"location":"data_capture/#capture-configuration","text":"The following configuration options are available for a capture: Element Purpose capture block key The name of the item to capture, e.g. user . store The name of the store in which to put the item. pathParam The name of the path parameter to capture. Must reference the resource path, e.g. userId for a path of /users/:userId queryParam The name of the query parameter to capture. requestHeader The name of the request header to capture. jsonPath The JsonPath expression to query the JSON body. Only works with JSON request bodies.","title":"Capture configuration"},{"location":"data_capture/#request-scoped-store","text":"There is a special request-scoped store, named request , which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request. The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template, but you don't need to persist it for later use. Here is an example combining capture and response template: Learn more about response templates . # part of your configuration file resources: - path: \"/users/:userName\" method: PUT capture: user: pathParam: userName store: request response: staticFile: example-template.json template: true Here is the corresponding template file: { \"userName\": \"${request.user}\" } If you were to make the following request: curl -X PUT http://localhost:8080/users/alice ...you would receive the following response: { \"userName\": \"alice\" }","title":"Request scoped store"},{"location":"data_capture/#capturing-the-request-body","text":"You can capture part or all of the request body using a JsonPath expression. For example, if the request body was: { \"name\": \"Alice\", \"address\": { \"street\": \"1 Main Street\", \"postCode\": \"PO5 7CO\" } } ...you could capture the name as follows: # part of your configuration file resources: - path: \"/users\" method: POST capture: firstName: jsonPath: $.name store: testStore In this example, the name property of the body would be stored in the 'firstName' item in the store named 'testStore'.","title":"Capturing the request body"},{"location":"data_capture/#constant-values","text":"In some scenarios, you may wish to capture a constant value. Example: plugin: rest - method: GET path: /test capture: # constant value receivedRequest: store: example const: yes response: statusCode: 200 In the example above, the value yes is stored in the 'example' store, with the name 'receivedRequest', when the given endpoint is hit.","title":"Constant values"},{"location":"data_capture/#capturing-an-object","text":"In some scenarios you may wish to capture an object instead of a single value. For example, to capture the address from the example above, use the JsonPath expression $.address - this will result in the entire address object being captured. You can retrieve this object in a script, by accessing the store named 'testStore', or you could use it in a JsonPath placeholder within a template .","title":"Capturing an object"},{"location":"data_capture/#dynamic-item-names","text":"You do not have to specify a constant value for the item name - you can use a property of the request, such as a query or path parameter, header or body element as the item name. Dynamic item names are useful when you want to capture collections of items, each with their own name derived from the request. Example: plugin: rest - method: PUT path: /users/admins/:userId capture: # constant value, but dynamic key adminUser: key: pathParam: userId store: adminUsers const: admin response: statusCode: 200 In the example above, an item corresponding to the userId parameter in the request is added to the 'adminUsers' store with the constant value admin . Note: Values do not have to be constant - you can combine dynamic item names and captured data.","title":"Dynamic item names"},{"location":"data_capture/#capture-performance","text":"Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data. Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference.","title":"Capture performance"},{"location":"data_capture/#examples","text":"data-capture","title":"Examples"},{"location":"embed_jvm/","text":"Embedding Imposter in your JVM tests You can embed the Imposter in your JVM tests, such as JUnit or TestNG. Typically, Imposter starts before your tests, providing synthetic responses to your unit under test. You connect your component under test to the mock HTTP endpoint provided by Imposter. Imposter starts before your test runs, such as in your test set-up method (e.g. @Before in JUnit), providing your application with simulated HTTP responses, in place of a real endpoint. Getting started For the version, choose the latest release from https://github.com/outofcoffee/imposter/releases Add the following Maven repository to your build tool: https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases Add the following Maven dependencies in your build tool: Component Group ID Artifact ID Version Unit test library io.gatehill.imposter distro-embedded As per Releases , e.g. 1.24.3 HTTP server io.gatehill.imposter imposter-server As per Releases , e.g. 1.24.3 OpenAPI plugin io.gatehill.imposter plugin-openapi As per Releases , e.g. 1.24.3 See the Dependencies section for full Maven and Gradle examples. OpenAPI example It is best to use a plugin-specific builder if it exists, such as io.gatehill.imposter.openapi.embedded.OpenApiImposterBuilder for the OpenAPI plugin. Let's assume you have an OpenAPI specification file: Path specFile = Paths.get(\"/path/to/openapi_file.yaml\"); Example using an OpenAPI spec as the source: MockEngine imposter = new OpenApiImposterBuilder<>() .withSpecificationFile(specFile) .startBlocking(); // mockEndpoint will look like http://localhost:5234/v1/pets String mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\"; // Your component under test can interact with this endpoint to get // simulated HTTP responses, in place of a real endpoint. For a working example, see OpenApiImposterBuilderTest Using a full configuration file You can also get access to advanced Imposter features by using a standard configuration file . Pass the path to the directory containing the configuration file: String configDir = Paths.get(\"/path/to/config_dir\"); Example using a directory containing an Imposter configuration file: MockEngine imposter = new ImposterBuilder<>() .withPluginClass(OpenApiPluginImpl.class) .withConfigurationDir(configDir) .startBlocking(); // mockEndpoint will look like http://localhost:5234/v1/pets String mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\"; // Your component under test can interact with this endpoint to get // simulated HTTP responses, in place of a real endpoint. Note the need to specify the plugin, which was implicit in the example above. For a working example, see ImposterBuilderTest Dependencies Build tool configuration for Gradle and Maven. Gradle Using Gradle, add the following to your build configuration: ext { // choose latest release from: https://github.com/outofcoffee/imposter/releases imposter_version = '1.24.3' } repositories { maven { // imposter maven repository url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/' } } dependencies { testImplementation \"io.gatehill.imposter:distro-embedded:$imposter_version\" testImplementation \"io.gatehill.imposter:imposter-server:$imposter_version\" testImplementation \"io.gatehill.imposter:plugin-openapi:$imposter_version\" // ... } Maven Using Maven, add the following to your POM: <project> ... <repositories> <repository> <id>imposter</id> <url>https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases</url> </repository> </repositories> ... <properties> <!-- choose latest release from https://github.com/outofcoffee/imposter/releases --> <imposter.version>1.24.3</imposter.version> </properties> ... <dependencies> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>distro-embedded</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-server</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>plugin-openapi</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> ... </dependencies> </project>","title":"Embedding Imposter in your JVM tests"},{"location":"embed_jvm/#embedding-imposter-in-your-jvm-tests","text":"You can embed the Imposter in your JVM tests, such as JUnit or TestNG. Typically, Imposter starts before your tests, providing synthetic responses to your unit under test. You connect your component under test to the mock HTTP endpoint provided by Imposter. Imposter starts before your test runs, such as in your test set-up method (e.g. @Before in JUnit), providing your application with simulated HTTP responses, in place of a real endpoint.","title":"Embedding Imposter in your JVM tests"},{"location":"embed_jvm/#getting-started","text":"For the version, choose the latest release from https://github.com/outofcoffee/imposter/releases Add the following Maven repository to your build tool: https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases Add the following Maven dependencies in your build tool: Component Group ID Artifact ID Version Unit test library io.gatehill.imposter distro-embedded As per Releases , e.g. 1.24.3 HTTP server io.gatehill.imposter imposter-server As per Releases , e.g. 1.24.3 OpenAPI plugin io.gatehill.imposter plugin-openapi As per Releases , e.g. 1.24.3 See the Dependencies section for full Maven and Gradle examples.","title":"Getting started"},{"location":"embed_jvm/#openapi-example","text":"It is best to use a plugin-specific builder if it exists, such as io.gatehill.imposter.openapi.embedded.OpenApiImposterBuilder for the OpenAPI plugin. Let's assume you have an OpenAPI specification file: Path specFile = Paths.get(\"/path/to/openapi_file.yaml\"); Example using an OpenAPI spec as the source: MockEngine imposter = new OpenApiImposterBuilder<>() .withSpecificationFile(specFile) .startBlocking(); // mockEndpoint will look like http://localhost:5234/v1/pets String mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\"; // Your component under test can interact with this endpoint to get // simulated HTTP responses, in place of a real endpoint. For a working example, see OpenApiImposterBuilderTest","title":"OpenAPI example"},{"location":"embed_jvm/#using-a-full-configuration-file","text":"You can also get access to advanced Imposter features by using a standard configuration file . Pass the path to the directory containing the configuration file: String configDir = Paths.get(\"/path/to/config_dir\"); Example using a directory containing an Imposter configuration file: MockEngine imposter = new ImposterBuilder<>() .withPluginClass(OpenApiPluginImpl.class) .withConfigurationDir(configDir) .startBlocking(); // mockEndpoint will look like http://localhost:5234/v1/pets String mockEndpoint = imposter.getBaseUrl() + \"/v1/pets\"; // Your component under test can interact with this endpoint to get // simulated HTTP responses, in place of a real endpoint. Note the need to specify the plugin, which was implicit in the example above. For a working example, see ImposterBuilderTest","title":"Using a full configuration file"},{"location":"embed_jvm/#dependencies","text":"Build tool configuration for Gradle and Maven.","title":"Dependencies"},{"location":"embed_jvm/#gradle","text":"Using Gradle, add the following to your build configuration: ext { // choose latest release from: https://github.com/outofcoffee/imposter/releases imposter_version = '1.24.3' } repositories { maven { // imposter maven repository url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/' } } dependencies { testImplementation \"io.gatehill.imposter:distro-embedded:$imposter_version\" testImplementation \"io.gatehill.imposter:imposter-server:$imposter_version\" testImplementation \"io.gatehill.imposter:plugin-openapi:$imposter_version\" // ... }","title":"Gradle"},{"location":"embed_jvm/#maven","text":"Using Maven, add the following to your POM: <project> ... <repositories> <repository> <id>imposter</id> <url>https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases</url> </repository> </repositories> ... <properties> <!-- choose latest release from https://github.com/outofcoffee/imposter/releases --> <imposter.version>1.24.3</imposter.version> </properties> ... <dependencies> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>distro-embedded</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-server</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>plugin-openapi</artifactId> <version>${imposter.version}</version> <scope>test</scope> </dependency> ... </dependencies> </project>","title":"Maven"},{"location":"extend/","text":"Extending Imposter in a custom application You can extend Imposter to build a custom JVM application. See io.gatehill.imposter.server.ImposterVerticle for an example of how to bootstrap the mock server. Dependencies Add the Imposter dependencies to your build tool. Gradle To add dependencies on Imposter, using Gradle, add the following to your build configuration: ext { // choose latest release from: https://github.com/outofcoffee/imposter/releases imposter_version = '1.0.0' } repositories { maven { // imposter maven repository url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/' } } dependencies { // core imposter dependencies implementation \"io.gatehill.imposter:imposter-core:$imposter_version\" implementation \"io.gatehill.imposter:imposter-server:$imposter_version\" // specific plugins implementation \"io.gatehill.imposter:plugin-openapi:$imposter_version\" // ... } Maven Using Maven, add the following to your POM: <project> ... <repositories> <repository> <id>imposter</id> <url>https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases</url> </repository> </repositories> ... <properties> <!-- choose latest release from https://github.com/outofcoffee/imposter/releases --> <imposter.version>1.0.0</imposter.version> </properties> ... <dependencies> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-core</artifactId> <version>${imposter.version}</version> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-server</artifactId> <version>${imposter.version}</version> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>plugin-openapi</artifactId> <version>${imposter.version}</version> </dependency> ... </dependencies> </project>","title":"Extending Imposter in a custom application"},{"location":"extend/#extending-imposter-in-a-custom-application","text":"You can extend Imposter to build a custom JVM application. See io.gatehill.imposter.server.ImposterVerticle for an example of how to bootstrap the mock server.","title":"Extending Imposter in a custom application"},{"location":"extend/#dependencies","text":"Add the Imposter dependencies to your build tool.","title":"Dependencies"},{"location":"extend/#gradle","text":"To add dependencies on Imposter, using Gradle, add the following to your build configuration: ext { // choose latest release from: https://github.com/outofcoffee/imposter/releases imposter_version = '1.0.0' } repositories { maven { // imposter maven repository url 'https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases/' } } dependencies { // core imposter dependencies implementation \"io.gatehill.imposter:imposter-core:$imposter_version\" implementation \"io.gatehill.imposter:imposter-server:$imposter_version\" // specific plugins implementation \"io.gatehill.imposter:plugin-openapi:$imposter_version\" // ... }","title":"Gradle"},{"location":"extend/#maven","text":"Using Maven, add the following to your POM: <project> ... <repositories> <repository> <id>imposter</id> <url>https://s3-eu-west-1.amazonaws.com/gatehillsoftware-maven/releases</url> </repository> </repositories> ... <properties> <!-- choose latest release from https://github.com/outofcoffee/imposter/releases --> <imposter.version>1.0.0</imposter.version> </properties> ... <dependencies> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-core</artifactId> <version>${imposter.version}</version> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>imposter-server</artifactId> <version>${imposter.version}</version> </dependency> <dependency> <groupId>io.gatehill.imposter</groupId> <artifactId>plugin-openapi</artifactId> <version>${imposter.version}</version> </dependency> ... </dependencies> </project>","title":"Maven"},{"location":"features/","text":"Features Imposter is a reliable, scriptable and extensible mock server for REST APIs, OpenAPI (and Swagger) specifications, Salesforce and HBase APIs. Run standalone mock servers, or embed mocks within your tests (supports JVM and Node.js). Dynamic responses can be scripted using JavaScript, Groovy or Java. Getting started To begin, check out our Getting started guide. See the User documentation for more. Highlights run standalone mocks in place of real systems turn an OpenAPI/Swagger file into a mock API for dev or QA (use it before the real API is built) decouple your integration tests from the cloud/back-end systems and take control of your dependencies validate your API requests against an OpenAPI specification capture data and retrieve later, or use in templates to for conditional responses Send dynamic responses: Provide mock responses using static files or customise behaviour based on characteristics of the request. Power users can control mock responses with JavaScript or Java/Groovy script engines. Advanced users can write their own plugins in a JVM language of their choice.","title":"Features"},{"location":"features/#features","text":"Imposter is a reliable, scriptable and extensible mock server for REST APIs, OpenAPI (and Swagger) specifications, Salesforce and HBase APIs. Run standalone mock servers, or embed mocks within your tests (supports JVM and Node.js). Dynamic responses can be scripted using JavaScript, Groovy or Java.","title":"Features"},{"location":"features/#getting-started","text":"To begin, check out our Getting started guide. See the User documentation for more.","title":"Getting started"},{"location":"features/#highlights","text":"run standalone mocks in place of real systems turn an OpenAPI/Swagger file into a mock API for dev or QA (use it before the real API is built) decouple your integration tests from the cloud/back-end systems and take control of your dependencies validate your API requests against an OpenAPI specification capture data and retrieve later, or use in templates to for conditional responses Send dynamic responses: Provide mock responses using static files or customise behaviour based on characteristics of the request. Power users can control mock responses with JavaScript or Java/Groovy script engines. Advanced users can write their own plugins in a JVM language of their choice.","title":"Highlights"},{"location":"features_plugins/","text":"Features and plugins Features Imposter allows certain features to be enabled or disabled. Fewer features lowers resource requirements. List of features Feature name Purpose Details Enabled by default metrics Collects and exposes telemetry. Metrics true stores Persistent or semi-persistent state. Stores true These can be controlled by setting the environment variable IMPOSTER_FEATURES : IMPOSTER_FEATURES=\"stores=false,metrics=true\" ...or Java system property imposter.features : -Dimposter.features=\"stores=false,metrics=true\" Plugins Imposter uses plugins to control its behaviour and provide specialised mocks. You load one or more plugins. The following sections describe the built-in plugins. You can also write your own, if you want to customise behaviour further. Plugin name Description Details config-detector Detects plugins from META-INF . Built-in. hbase HBase plugin. HBase plugin meta-detector Detects plugins from *-config files. Built-in. openapi OpenAPI (and Swagger) plugin. OpenAPI (and Swagger) plugin rest REST plugin. REST plugin sfdc SFDC (Salesforce) plugin. SFDC (Salesforce) plugin","title":"Features and plugins"},{"location":"features_plugins/#features-and-plugins","text":"","title":"Features and plugins"},{"location":"features_plugins/#features","text":"Imposter allows certain features to be enabled or disabled. Fewer features lowers resource requirements.","title":"Features"},{"location":"features_plugins/#list-of-features","text":"Feature name Purpose Details Enabled by default metrics Collects and exposes telemetry. Metrics true stores Persistent or semi-persistent state. Stores true These can be controlled by setting the environment variable IMPOSTER_FEATURES : IMPOSTER_FEATURES=\"stores=false,metrics=true\" ...or Java system property imposter.features : -Dimposter.features=\"stores=false,metrics=true\"","title":"List of features"},{"location":"features_plugins/#plugins","text":"Imposter uses plugins to control its behaviour and provide specialised mocks. You load one or more plugins. The following sections describe the built-in plugins. You can also write your own, if you want to customise behaviour further. Plugin name Description Details config-detector Detects plugins from META-INF . Built-in. hbase HBase plugin. HBase plugin meta-detector Detects plugins from *-config files. Built-in. openapi OpenAPI (and Swagger) plugin. OpenAPI (and Swagger) plugin rest REST plugin. REST plugin sfdc SFDC (Salesforce) plugin. SFDC (Salesforce) plugin","title":"Plugins"},{"location":"getting_started/","text":"Getting started There are many ways to run Imposter. They broadly fit in two categories - running a standalone server, or embedding within tests. Standalone mock server Using the command line client - see Imposter CLI As a Docker container - see Imposter Docker container As a JAR file on the JVM - see Imposter JAR file Embedded in tests Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings Choosing an approach If you are looking for a quick local development solution, use the CLI . If you want to run Imposter as a standalone mock server, you can run it as a Docker container . If Docker isn't your thing, or you want to build Imposter yourself, you can use it as a standalone JAR file . Standalone servers are often useful when you require long-lived mock instances. You can also use it as a mock server for your unit tests on the JVM or Node.js , starting it before your tests, providing synthetic responses to your unit under test. Embedded instances tend to be short-lived and exist only for the duration of your test execution. Examples Let's assume your configuration is in a folder named config . CLI example: imposter up ./config -p 8080 Docker example: docker run -ti -p 8080:8080 -v $PWD/config:/opt/imposter/config outofcoffee/imposter-rest Standalone Java example: java -jar ./imposter.jar --configDir ./config Your mock server is now running! These examples start a mock server using the simple REST plugin , serving responses based on the configuration files inside the config folder. You can hit the URL http://localhost:8080/example to see the mock response. What's next Learn how to use Imposter with the Configuration guide .","title":"Getting started"},{"location":"getting_started/#getting-started","text":"There are many ways to run Imposter. They broadly fit in two categories - running a standalone server, or embedding within tests.","title":"Getting started"},{"location":"getting_started/#standalone-mock-server","text":"Using the command line client - see Imposter CLI As a Docker container - see Imposter Docker container As a JAR file on the JVM - see Imposter JAR file","title":"Standalone mock server"},{"location":"getting_started/#embedded-in-tests","text":"Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings","title":"Embedded in tests"},{"location":"getting_started/#choosing-an-approach","text":"If you are looking for a quick local development solution, use the CLI . If you want to run Imposter as a standalone mock server, you can run it as a Docker container . If Docker isn't your thing, or you want to build Imposter yourself, you can use it as a standalone JAR file . Standalone servers are often useful when you require long-lived mock instances. You can also use it as a mock server for your unit tests on the JVM or Node.js , starting it before your tests, providing synthetic responses to your unit under test. Embedded instances tend to be short-lived and exist only for the duration of your test execution.","title":"Choosing an approach"},{"location":"getting_started/#examples","text":"Let's assume your configuration is in a folder named config . CLI example: imposter up ./config -p 8080 Docker example: docker run -ti -p 8080:8080 -v $PWD/config:/opt/imposter/config outofcoffee/imposter-rest Standalone Java example: java -jar ./imposter.jar --configDir ./config Your mock server is now running! These examples start a mock server using the simple REST plugin , serving responses based on the configuration files inside the config folder. You can hit the URL http://localhost:8080/example to see the mock response.","title":"Examples"},{"location":"getting_started/#whats-next","text":"Learn how to use Imposter with the Configuration guide .","title":"What's next"},{"location":"hbase_plugin/","text":"HBase plugin Plugin name: hbase Plugin class: io.gatehill.imposter.plugin.hbase.HBasePluginImpl Features Basic HBase mock implementation. Supports protobuf or JSON for wire transport. Dummy Scanner queries. Individual table row/record retrieval. Configuration Read the Configuration section to understand how to configure Imposter. Additional context objects Object Type Description tableName String The name of the HBase table. responsePhase io.gatehill.imposter.plugin.hbase.model.ResponsePhase The type of response being served. scannerFilterPrefix String The prefix from the filter of the result scanner. recordInfo io.gatehill.imposter.plugin.hbase.model.RecordInfo Information about the requested record, if a single record is requested. Using the plugin Note: When using HBase Scanners, this plugin will return the 'server URL' in the Location header of the scanner creation response. You might want to consider setting the serverUrl property explicitly to the publicly-accessible address of the mock server, as described in the Usage section. Example For working examples, see: plugin/hbase/src/test/resources/config Let's assume your configuration is in a folder named config . Docker example: docker run -ti -p 8080:8080 \\ -v $PWD/config:/opt/imposter/config \\ outofcoffee/imposter-hbase \\ --serverUrl http://localhost:8080 Standalone Java example: java -jar distro/hbase/build/libs/imposter-hbase.jar \\ --configDir ./config \\ --serverUrl http://localhost:8080 This starts a mock server using the HBase plugin. Responses are served based on the configuration files inside the config folder. Using the example above, you can connect an HBase client, such as Apache RemoteHTable , to http://localhost:8080/ to interact with the API. In this example, you can interact with the exampleTable table, as defined in hbase-plugin-config.json and hbase-plugin-data.json .","title":"HBase plugin"},{"location":"hbase_plugin/#hbase-plugin","text":"Plugin name: hbase Plugin class: io.gatehill.imposter.plugin.hbase.HBasePluginImpl","title":"HBase plugin"},{"location":"hbase_plugin/#features","text":"Basic HBase mock implementation. Supports protobuf or JSON for wire transport. Dummy Scanner queries. Individual table row/record retrieval.","title":"Features"},{"location":"hbase_plugin/#configuration","text":"Read the Configuration section to understand how to configure Imposter.","title":"Configuration"},{"location":"hbase_plugin/#additional-context-objects","text":"Object Type Description tableName String The name of the HBase table. responsePhase io.gatehill.imposter.plugin.hbase.model.ResponsePhase The type of response being served. scannerFilterPrefix String The prefix from the filter of the result scanner. recordInfo io.gatehill.imposter.plugin.hbase.model.RecordInfo Information about the requested record, if a single record is requested.","title":"Additional context objects"},{"location":"hbase_plugin/#using-the-plugin","text":"Note: When using HBase Scanners, this plugin will return the 'server URL' in the Location header of the scanner creation response. You might want to consider setting the serverUrl property explicitly to the publicly-accessible address of the mock server, as described in the Usage section.","title":"Using the plugin"},{"location":"hbase_plugin/#example","text":"For working examples, see: plugin/hbase/src/test/resources/config Let's assume your configuration is in a folder named config . Docker example: docker run -ti -p 8080:8080 \\ -v $PWD/config:/opt/imposter/config \\ outofcoffee/imposter-hbase \\ --serverUrl http://localhost:8080 Standalone Java example: java -jar distro/hbase/build/libs/imposter-hbase.jar \\ --configDir ./config \\ --serverUrl http://localhost:8080 This starts a mock server using the HBase plugin. Responses are served based on the configuration files inside the config folder. Using the example above, you can connect an HBase client, such as Apache RemoteHTable , to http://localhost:8080/ to interact with the API. In this example, you can interact with the exampleTable table, as defined in hbase-plugin-config.json and hbase-plugin-data.json .","title":"Example"},{"location":"metrics_logs_telemetry/","text":"Metrics, logs and telemetry Status endpoint Imposter exposes a status endpoint under /system/status This is useful as a healthcheck endpoint, such as for liveness or readiness checks. $ curl http://localhost:8080/system/status { \"status\":\"ok\", \"version\":\"1.20.0\" } Metrics Imposter exposes telemetry using Prometheus under /system/metrics This enables you to examine track various metrics, such as response time, error rates, total request count etc. $ curl http://localhost:8080/system/metrics # HELP vertx_http_server_bytesReceived Number of bytes received by the server # TYPE vertx_http_server_bytesReceived summary vertx_http_server_bytesReceived_count 6.0 # HELP vertx_http_server_requestCount_total Number of processed requests # TYPE vertx_http_server_requestCount_total counter vertx_http_server_requestCount_total{code=\"200\",method=\"GET\",} 5.0 # HELP vertx_http_server_connections Number of opened connections to the server # TYPE vertx_http_server_connections gauge vertx_http_server_connections 2.0 # HELP vertx_http_server_responseTime_seconds Request processing time # TYPE vertx_http_server_responseTime_seconds summary vertx_http_server_responseTime_seconds_count{code=\"200\",method=\"GET\",} 5.0 vertx_http_server_responseTime_seconds_sum{code=\"200\",method=\"GET\",} 0.1405811 # HELP vertx_http_server_responseTime_seconds_max Request processing time # TYPE vertx_http_server_responseTime_seconds_max gauge vertx_http_server_responseTime_seconds_max{code=\"200\",method=\"GET\",} 0.1039024 For example, to calculate the average response time, use the following PromQL: vertx_http_server_responseTime_seconds_sum / vertx_http_server_responseTime_seconds_count Other useful metrics: Metric name Purpose response_file_cache_entries The number of cached response files script_execution_duration Script engine execution duration in seconds script_cache_entries The number of cached compiled scripts Also see the metrics example . Logs Logs are printed to stdout. You can control the logging level using the following environment variable: # also supports WARN, INFO, DEBUG etc. export IMPOSTER_LOG_LEVEL=\"TRACE\" Internally, Log4J2 is used, so the usual configuration options apply.","title":"Metrics, logs and telemetry"},{"location":"metrics_logs_telemetry/#metrics-logs-and-telemetry","text":"","title":"Metrics, logs and telemetry"},{"location":"metrics_logs_telemetry/#status-endpoint","text":"Imposter exposes a status endpoint under /system/status This is useful as a healthcheck endpoint, such as for liveness or readiness checks. $ curl http://localhost:8080/system/status { \"status\":\"ok\", \"version\":\"1.20.0\" }","title":"Status endpoint"},{"location":"metrics_logs_telemetry/#metrics","text":"Imposter exposes telemetry using Prometheus under /system/metrics This enables you to examine track various metrics, such as response time, error rates, total request count etc. $ curl http://localhost:8080/system/metrics # HELP vertx_http_server_bytesReceived Number of bytes received by the server # TYPE vertx_http_server_bytesReceived summary vertx_http_server_bytesReceived_count 6.0 # HELP vertx_http_server_requestCount_total Number of processed requests # TYPE vertx_http_server_requestCount_total counter vertx_http_server_requestCount_total{code=\"200\",method=\"GET\",} 5.0 # HELP vertx_http_server_connections Number of opened connections to the server # TYPE vertx_http_server_connections gauge vertx_http_server_connections 2.0 # HELP vertx_http_server_responseTime_seconds Request processing time # TYPE vertx_http_server_responseTime_seconds summary vertx_http_server_responseTime_seconds_count{code=\"200\",method=\"GET\",} 5.0 vertx_http_server_responseTime_seconds_sum{code=\"200\",method=\"GET\",} 0.1405811 # HELP vertx_http_server_responseTime_seconds_max Request processing time # TYPE vertx_http_server_responseTime_seconds_max gauge vertx_http_server_responseTime_seconds_max{code=\"200\",method=\"GET\",} 0.1039024 For example, to calculate the average response time, use the following PromQL: vertx_http_server_responseTime_seconds_sum / vertx_http_server_responseTime_seconds_count Other useful metrics: Metric name Purpose response_file_cache_entries The number of cached response files script_execution_duration Script engine execution duration in seconds script_cache_entries The number of cached compiled scripts Also see the metrics example .","title":"Metrics"},{"location":"metrics_logs_telemetry/#logs","text":"Logs are printed to stdout. You can control the logging level using the following environment variable: # also supports WARN, INFO, DEBUG etc. export IMPOSTER_LOG_LEVEL=\"TRACE\" Internally, Log4J2 is used, so the usual configuration options apply.","title":"Logs"},{"location":"openapi_plugin/","text":"OpenAPI (and Swagger) plugin Plugin name: openapi Plugin class: io.gatehill.imposter.plugin.openapi.OpenApiPluginImpl The plugin provides support for OpenAPI (and Swagger) specifications. Features Creates mock endpoints from OpenAPI/Swagger v2 and OpenAPI v3 API specifications. Serves response examples embedded in the specification. Optionally validates your HTTP requests to ensure they match the OpenAPI specification. Also supports static response files and script-driven responses, using status code, response files etc. Provides an interactive API sandbox at /_spec Configuration Read the Configuration section to understand how to configure Imposter. Additional context objects Object Type Description operation io.swagger.models.Operation The OpenAPI operation for the request. Using the plugin A great way to use this plugin is to take advantage of the built in examples feature of OpenAPI/Swagger files. These provide a standard way to document sample responses for each API response. This plugin will match the example to serve using a combination of: matching URI/path matching method matching content type in Accept HTTP request header to the produces property of the response matching status code to the response Imposter will return the first response found that matches the path and method. You can override the behaviour by setting the status code for a given combination of path and method (see below). Typically, you will use the configuration file <something>-config.yaml to override the status code, and thus the content of the response, however, you can use the in-built script engine to gain further control of the response data, headers etc. (see below). You can also use the interactive API sandbox at /_spec ; e.g. http://localhost:8080/_spec , which looks like this: Example Here is an example configuration file: # petstore-config.yaml --- plugin: openapi specFile: petstore.yaml In this example, we are using an OpenAPI specification file ( petstore.yaml ) containing the following API: swagger: \"2.0\" info: version: \"1.0.0\" title: \"Swagger Petstore\" consumes: - \"application/json\" produces: - \"application/json\" paths: /pets: get: description: \"Returns all pets from the system\" produces: - \"application/json\" responses: \"200\": description: \"A list of pets.\" schema: type: \"array\" items: $ref: \"#/definitions/Pet\" examples: application/json: |- [ { \"id\": 101, \"name\": \"Cat\" }, { \"id\": 102, \"name\": \"Dog\" } ] definitions: Pet: type: \"object\" required: - \"id\" - \"name\" properties: id: type: \"integer\" format: \"int64\" name: type: \"string\" A few things to call out: We\u2019ve defined the endpoint /pets as expecting an HTTP GET request We\u2019ve said it will produce JSON responses One response is defined for the HTTP 200 case We\u2019ve defined a data model in the definitions section We\u2019ve provided an example response \u2014 the same JSON array described earlier Start Imposter with the OpenAPI plugin Let's assume your configuration is in the directory: docs/examples/openapi/simple . Here are a few ways to start a mock running on port 8080. CLI example: imposter up -p 8080 ./docs/examples/openapi/simple Docker example: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/openapi/simple:/opt/imposter/config \\ outofcoffee/imposter-openapi Java JAR example: java -jar distro/openapi/build/libs/imposter-openapi.jar \\ --configDir ./docs/examples/openapi/simple This starts a mock server using the OpenAPI plugin. Responses are served based on the OpenAPI specification petstore.yaml . Using the example above, you can interact with the APIs with examples in the Swagger specification at their respective endpoints under http://localhost:8080/<endpoint path> . Send an HTTP request to the /pets path defined in the configuration file to see the example response: $ curl -v \"http://localhost:8080/pets\" ... HTTP/1.1 200 OK ... [ { \"id\": 101, \"name\": \"Cat\" }, { \"id\": 102, \"name\": \"Dog\" } ] For specific information about the endpoints, see the interactive sandbox at http://localhost:8080/_spec . Once you're finished, stop the server with CTRL+C. For more working examples, see: examples/openapi Validating requests against the specification Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification. To enable this, set the validation.request configuration option to true : # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification. If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors. For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID': $ curl -v -X POST http://localhost:8080/pets Note that our request does not provide either a request body or header. This results in the following log entries: WARN i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed. [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. ...and the following HTTP response: HTTP/1.1 400 Bad Request Content-Type: text/plain Content-Length: 261 Request validation failed: [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required. Note that if the request body were provided, its structure would be validated against the corresponding schema entry. For more information about validation, including how to ignore certain conditions, see the OpenAPI validation document. Overriding status code Sometimes you might want to force a particular status code to be returned, or use other specific behaviours. To do this, you can use the resources configuration: # override-status-code-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-status-codes.yaml\" resources: - path: \"/pets\" method: post response: statusCode: 201 - path: \"/pets/:petId\" method: put response: statusCode: 202 Here, POST requests to the /pets endpoint will default to the HTTP 201 status code. If there is a corresponding response example for the 201 status, this will be returned in the HTTP response. The path property supports placeholders, using the Vert.x Web colon format, so in the second example above, PUT requests to the endpoint /pets/<some ID> will return a 202 status. Overriding examples You can make Imposter select a specific example to use as the response body. # override-examples-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-examples.yaml\" resources: - path: /pets/1 method: get response: exampleName: catExample - path: /pets/2 method: get response: exampleName: dogExample As with the standard scripting functionality , you can also specify a static response file to use instead of an example: # ... as above ... - path: /pets/3 method: get response: staticFile: tortoise.json statusCode: 200 Conditional responses based on query parameters You can control response behaviour based on the value of query parameters # override-examples-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-status-codes.yaml\" resources: # default to HTTP 400 response - path: \"/pets\" method: \"get\" response: statusCode: 400 # return HTTP 200 if request includes query parameter 'foo=bar' - path: \"/pets\" method: \"get\" queryParams: foo: bar response: statusCode: 200 $ curl -v -X POST http://localhost:8080/pets HTTP/1.1 400 Bad Request $ curl -v -X POST http://localhost:8080/pets?foo=bar HTTP/1.1 200 OK Object response examples Imposter has basic support for response examples defined as objects, for example an API specification like object-examples.yaml - see examples/openapi/object-examples . The salient part of the response is as follows: responses: \"200\": description: team response schema: type: object items: $ref: '#/definitions/Team' examples: application/json: id: 10 name: Engineering Note that the example is specified as an object, rather than literal JSON. Imposter currently supports JSON and YAML serialised content types in the response if they are specified in this way. If you want to return a different format, return a literal string, such as those above. Scripted responses (advanced) For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information. For a simple script, see examples/openapi/scripted-named-example for a working example. Example Here we set the response.scriptFile property in the configuration file: # scripted-openapi-config.yaml --- plugin: openapi specFile: petstore.yaml response: scriptFile: example.groovy As a reminder, you can use either JavaScript ( .js ) or Groovy ( .groovy ) languages for your scripts. Now, example.groovy can control the responses, such as: a specific OpenAPI example name to return respond().withExampleName('example1') the content of a file to return respond().withFile('some-file.json') a literal string to return respond().withData('{ \"foo\": \"bar\" }') Returning a named example OpenAPI specifications allow API authors to provide examples of requests, responses, parameters and schema items. You can return a specific named example from the specification in your script using the withExampleName(String) method. if (context.request.pathParams.petId == '2') { respond().withExampleName('dogExample') } This selects the example from the OpenAPI examples section for the API response. paths: /pets/{petId}: get: # (...some parts of operation excluded for brevity) responses: '200': content: application/json: schema: $ref: \"#/components/schemas/Pet\" examples: # the example to return is selected by the script catExample: value: |- { \"id\": 1, \"name\": \"Cat\" } dogExample: value: |- { \"id\": 2, \"name\": \"Dog\" } Examples scripted-named-example scripted-named-example-js static-named-example OpenAPI specification locations OpenAPI files can be provided as a relative file, an HTTP(S) URL or a file in an S3 bucket. Some examples: A file in the same directory as the configuration file: plugin: openapi specFile: sample_spec.yaml At a URL: plugin: openapi specFile: https://example.com/sample_spec.yaml In an S3 bucket: plugin: openapi specFile: s3://example-bucket/sample_spec.yaml When using S3, set up your AWS profile/region/credentials as per standard AWS practice. For example, using an instance profile in EC2, environment variables or the various local environment configuration locations for providing AWS credentials.","title":"OpenAPI (and Swagger) plugin"},{"location":"openapi_plugin/#openapi-and-swagger-plugin","text":"Plugin name: openapi Plugin class: io.gatehill.imposter.plugin.openapi.OpenApiPluginImpl The plugin provides support for OpenAPI (and Swagger) specifications.","title":"OpenAPI (and Swagger) plugin"},{"location":"openapi_plugin/#features","text":"Creates mock endpoints from OpenAPI/Swagger v2 and OpenAPI v3 API specifications. Serves response examples embedded in the specification. Optionally validates your HTTP requests to ensure they match the OpenAPI specification. Also supports static response files and script-driven responses, using status code, response files etc. Provides an interactive API sandbox at /_spec","title":"Features"},{"location":"openapi_plugin/#configuration","text":"Read the Configuration section to understand how to configure Imposter.","title":"Configuration"},{"location":"openapi_plugin/#additional-context-objects","text":"Object Type Description operation io.swagger.models.Operation The OpenAPI operation for the request.","title":"Additional context objects"},{"location":"openapi_plugin/#using-the-plugin","text":"A great way to use this plugin is to take advantage of the built in examples feature of OpenAPI/Swagger files. These provide a standard way to document sample responses for each API response. This plugin will match the example to serve using a combination of: matching URI/path matching method matching content type in Accept HTTP request header to the produces property of the response matching status code to the response Imposter will return the first response found that matches the path and method. You can override the behaviour by setting the status code for a given combination of path and method (see below). Typically, you will use the configuration file <something>-config.yaml to override the status code, and thus the content of the response, however, you can use the in-built script engine to gain further control of the response data, headers etc. (see below). You can also use the interactive API sandbox at /_spec ; e.g. http://localhost:8080/_spec , which looks like this:","title":"Using the plugin"},{"location":"openapi_plugin/#example","text":"Here is an example configuration file: # petstore-config.yaml --- plugin: openapi specFile: petstore.yaml In this example, we are using an OpenAPI specification file ( petstore.yaml ) containing the following API: swagger: \"2.0\" info: version: \"1.0.0\" title: \"Swagger Petstore\" consumes: - \"application/json\" produces: - \"application/json\" paths: /pets: get: description: \"Returns all pets from the system\" produces: - \"application/json\" responses: \"200\": description: \"A list of pets.\" schema: type: \"array\" items: $ref: \"#/definitions/Pet\" examples: application/json: |- [ { \"id\": 101, \"name\": \"Cat\" }, { \"id\": 102, \"name\": \"Dog\" } ] definitions: Pet: type: \"object\" required: - \"id\" - \"name\" properties: id: type: \"integer\" format: \"int64\" name: type: \"string\" A few things to call out: We\u2019ve defined the endpoint /pets as expecting an HTTP GET request We\u2019ve said it will produce JSON responses One response is defined for the HTTP 200 case We\u2019ve defined a data model in the definitions section We\u2019ve provided an example response \u2014 the same JSON array described earlier","title":"Example"},{"location":"openapi_plugin/#start-imposter-with-the-openapi-plugin","text":"Let's assume your configuration is in the directory: docs/examples/openapi/simple . Here are a few ways to start a mock running on port 8080. CLI example: imposter up -p 8080 ./docs/examples/openapi/simple Docker example: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/openapi/simple:/opt/imposter/config \\ outofcoffee/imposter-openapi Java JAR example: java -jar distro/openapi/build/libs/imposter-openapi.jar \\ --configDir ./docs/examples/openapi/simple This starts a mock server using the OpenAPI plugin. Responses are served based on the OpenAPI specification petstore.yaml . Using the example above, you can interact with the APIs with examples in the Swagger specification at their respective endpoints under http://localhost:8080/<endpoint path> . Send an HTTP request to the /pets path defined in the configuration file to see the example response: $ curl -v \"http://localhost:8080/pets\" ... HTTP/1.1 200 OK ... [ { \"id\": 101, \"name\": \"Cat\" }, { \"id\": 102, \"name\": \"Dog\" } ] For specific information about the endpoints, see the interactive sandbox at http://localhost:8080/_spec . Once you're finished, stop the server with CTRL+C. For more working examples, see: examples/openapi","title":"Start Imposter with the OpenAPI plugin"},{"location":"openapi_plugin/#validating-requests-against-the-specification","text":"Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification. To enable this, set the validation.request configuration option to true : # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification. If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors. For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID': $ curl -v -X POST http://localhost:8080/pets Note that our request does not provide either a request body or header. This results in the following log entries: WARN i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed. [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. ...and the following HTTP response: HTTP/1.1 400 Bad Request Content-Type: text/plain Content-Length: 261 Request validation failed: [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required. Note that if the request body were provided, its structure would be validated against the corresponding schema entry. For more information about validation, including how to ignore certain conditions, see the OpenAPI validation document.","title":"Validating requests against the specification"},{"location":"openapi_plugin/#overriding-status-code","text":"Sometimes you might want to force a particular status code to be returned, or use other specific behaviours. To do this, you can use the resources configuration: # override-status-code-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-status-codes.yaml\" resources: - path: \"/pets\" method: post response: statusCode: 201 - path: \"/pets/:petId\" method: put response: statusCode: 202 Here, POST requests to the /pets endpoint will default to the HTTP 201 status code. If there is a corresponding response example for the 201 status, this will be returned in the HTTP response. The path property supports placeholders, using the Vert.x Web colon format, so in the second example above, PUT requests to the endpoint /pets/<some ID> will return a 202 status.","title":"Overriding status code"},{"location":"openapi_plugin/#overriding-examples","text":"You can make Imposter select a specific example to use as the response body. # override-examples-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-examples.yaml\" resources: - path: /pets/1 method: get response: exampleName: catExample - path: /pets/2 method: get response: exampleName: dogExample As with the standard scripting functionality , you can also specify a static response file to use instead of an example: # ... as above ... - path: /pets/3 method: get response: staticFile: tortoise.json statusCode: 200","title":"Overriding examples"},{"location":"openapi_plugin/#conditional-responses-based-on-query-parameters","text":"You can control response behaviour based on the value of query parameters # override-examples-config.yaml --- plugin: \"openapi\" specFile: \"spec-with-multiple-status-codes.yaml\" resources: # default to HTTP 400 response - path: \"/pets\" method: \"get\" response: statusCode: 400 # return HTTP 200 if request includes query parameter 'foo=bar' - path: \"/pets\" method: \"get\" queryParams: foo: bar response: statusCode: 200 $ curl -v -X POST http://localhost:8080/pets HTTP/1.1 400 Bad Request $ curl -v -X POST http://localhost:8080/pets?foo=bar HTTP/1.1 200 OK","title":"Conditional responses based on query parameters"},{"location":"openapi_plugin/#object-response-examples","text":"Imposter has basic support for response examples defined as objects, for example an API specification like object-examples.yaml - see examples/openapi/object-examples . The salient part of the response is as follows: responses: \"200\": description: team response schema: type: object items: $ref: '#/definitions/Team' examples: application/json: id: 10 name: Engineering Note that the example is specified as an object, rather than literal JSON. Imposter currently supports JSON and YAML serialised content types in the response if they are specified in this way. If you want to return a different format, return a literal string, such as those above.","title":"Object response examples"},{"location":"openapi_plugin/#scripted-responses-advanced","text":"For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information. For a simple script, see examples/openapi/scripted-named-example for a working example.","title":"Scripted responses (advanced)"},{"location":"openapi_plugin/#example_1","text":"Here we set the response.scriptFile property in the configuration file: # scripted-openapi-config.yaml --- plugin: openapi specFile: petstore.yaml response: scriptFile: example.groovy As a reminder, you can use either JavaScript ( .js ) or Groovy ( .groovy ) languages for your scripts. Now, example.groovy can control the responses, such as: a specific OpenAPI example name to return respond().withExampleName('example1') the content of a file to return respond().withFile('some-file.json') a literal string to return respond().withData('{ \"foo\": \"bar\" }')","title":"Example"},{"location":"openapi_plugin/#returning-a-named-example","text":"OpenAPI specifications allow API authors to provide examples of requests, responses, parameters and schema items. You can return a specific named example from the specification in your script using the withExampleName(String) method. if (context.request.pathParams.petId == '2') { respond().withExampleName('dogExample') } This selects the example from the OpenAPI examples section for the API response. paths: /pets/{petId}: get: # (...some parts of operation excluded for brevity) responses: '200': content: application/json: schema: $ref: \"#/components/schemas/Pet\" examples: # the example to return is selected by the script catExample: value: |- { \"id\": 1, \"name\": \"Cat\" } dogExample: value: |- { \"id\": 2, \"name\": \"Dog\" }","title":"Returning a named example"},{"location":"openapi_plugin/#examples","text":"scripted-named-example scripted-named-example-js static-named-example","title":"Examples"},{"location":"openapi_plugin/#openapi-specification-locations","text":"OpenAPI files can be provided as a relative file, an HTTP(S) URL or a file in an S3 bucket. Some examples: A file in the same directory as the configuration file: plugin: openapi specFile: sample_spec.yaml At a URL: plugin: openapi specFile: https://example.com/sample_spec.yaml In an S3 bucket: plugin: openapi specFile: s3://example-bucket/sample_spec.yaml When using S3, set up your AWS profile/region/credentials as per standard AWS practice. For example, using an instance profile in EC2, environment variables or the various local environment configuration locations for providing AWS credentials.","title":"OpenAPI specification locations"},{"location":"openapi_validation/","text":"OpenAPI request validation This document describes how to validate HTTP requests against an OpenAPI specification when using the OpenAPI plugin . Validating requests against the specification Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification. To enable this, set the validation.request configuration option to true : # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification. If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors. For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID': $ curl -v -X POST http://localhost:8080/pets Note that our request does not provide either a request body or header. This results in the following log entries: WARN i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed. [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. ...and the following HTTP response: HTTP/1.1 400 Bad Request Content-Type: text/plain Content-Length: 261 Request validation failed: [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required: /pets/{petId}: put: summary: Update a specific pet operationId: updatePet parameters: - in: path name: petId required: true requestBody: required: true content: application/json: schema: $ref: \"#/components/schemas/Pet\" Note that if the request body were provided, its structure would be validated against the corresponding schema entry. See examples/openapi/request-validation for a working example. Configuring issue behaviour When validation issues occur, the possible behaviours are: fail the request ( fail or true ) log only ( log ) ignore ( ignore or false ) Fail the request # fail the request if validation issues occur validation: request: fail Log only # just log if validation issues occur validation: request: log Ignore # ignore validation issues validation: request: ignore If the validation block is not specified, validation issue behaviour is controlled by the IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR environment variable. The default value is ignore . Possible values are the same as the configuration file (above). Configuring validation levels You can control which validation checks are considered errors, and which are ignored. To do this, use the validation.levels section, for example: # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true levels: validation.request.body.missing: WARN validation.request.security.invalid: ERROR In the example above, if the request body were missing, Imposter would not treat this as a validation error. The validation.levels block is a map of validation key (i.e. a type of validation check) to level ( ERROR or WARN ). See the full list of validations at the swagger-request-validator-core project .","title":"OpenAPI validation"},{"location":"openapi_validation/#openapi-request-validation","text":"This document describes how to validate HTTP requests against an OpenAPI specification when using the OpenAPI plugin .","title":"OpenAPI request validation"},{"location":"openapi_validation/#validating-requests-against-the-specification","text":"Imposter allows you to validate your HTTP requests to ensure they match the OpenAPI specification. To enable this, set the validation.request configuration option to true : # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true Now, for every incoming request to a valid combination of path and HTTP method, Imposter will validate the request parameters, headers and body against the corresponding part of the specification. If a request fails validation, Imposter logs the validation errors then responds with an HTTP 400 status and, optionally, a report of the errors. For example, let's make an HTTP request to an endpoint whose specification requires a request body and also requires a header, named 'X-Correlation-ID': $ curl -v -X POST http://localhost:8080/pets Note that our request does not provide either a request body or header. This results in the following log entries: WARN i.g.i.p.o.s.SpecificationServiceImpl - Validation failed for POST /pets: Validation failed. [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. ...and the following HTTP response: HTTP/1.1 400 Bad Request Content-Type: text/plain Content-Length: 261 Request validation failed: [ERROR][REQUEST][POST /pets @header.X-CorrelationID] Header parameter 'X-CorrelationID' is required on path '/pets' but not found in request. [ERROR][REQUEST][POST /pets @body] A request body is required but none found. This is because in the corresponding part of the OpenAPI specification, both the header and request body are marked as required: /pets/{petId}: put: summary: Update a specific pet operationId: updatePet parameters: - in: path name: petId required: true requestBody: required: true content: application/json: schema: $ref: \"#/components/schemas/Pet\" Note that if the request body were provided, its structure would be validated against the corresponding schema entry. See examples/openapi/request-validation for a working example.","title":"Validating requests against the specification"},{"location":"openapi_validation/#configuring-issue-behaviour","text":"When validation issues occur, the possible behaviours are: fail the request ( fail or true ) log only ( log ) ignore ( ignore or false )","title":"Configuring issue behaviour"},{"location":"openapi_validation/#fail-the-request","text":"# fail the request if validation issues occur validation: request: fail","title":"Fail the request"},{"location":"openapi_validation/#log-only","text":"# just log if validation issues occur validation: request: log","title":"Log only"},{"location":"openapi_validation/#ignore","text":"# ignore validation issues validation: request: ignore If the validation block is not specified, validation issue behaviour is controlled by the IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR environment variable. The default value is ignore . Possible values are the same as the configuration file (above).","title":"Ignore"},{"location":"openapi_validation/#configuring-validation-levels","text":"You can control which validation checks are considered errors, and which are ignored. To do this, use the validation.levels section, for example: # validating-request-config.yaml --- plugin: \"openapi\" specFile: \"example-spec.yaml\" validation: request: true levels: validation.request.body.missing: WARN validation.request.security.invalid: ERROR In the example above, if the request body were missing, Imposter would not treat this as a validation error. The validation.levels block is a map of validation key (i.e. a type of validation check) to level ( ERROR or WARN ). See the full list of validations at the swagger-request-validator-core project .","title":"Configuring validation levels"},{"location":"performance_simulation/","text":"Performance simulation Characteristics like response latency can be simulated. Injecting delays Delays can be injected via a configuration driven approach or a script driven approach. Delays are specified in milliseconds. The delay controls the time added after any request processing has completed (scripts, plugins etc.). So, if a normal un-delayed request takes 0.05 seconds and a delay of 100ms is added, then the response will be transmitted to the client after 105ms. Delays can be specified as an exact value, or a range. If a range is specified, then a random value (roughly uniformly distributed) will be selected between the minimum and maximum range values. Configuration driven Specify the delay section in configuration: For the root resource: # ... response: statusCode: 200 staticFile: \"response.json\" # exactly 1000ms delay delay: exact: 1000 For a specific resource (e.g. OpenAPI or REST plugin): # ... resources: - method: GET path: /example response: statusCode: 200 staticFile: \"response.json\" # delay in range of 500ms-1500ms delay: min: 500 max: 1500 Script driven If using Scripting , use the withDelay(exactDelay) and withDelayRange(minDelay, maxDelay) methods: For an exact delay: respond() .withStatusCode(200) .withFile('response.json') .withDelay(1000) For a delay within a range: respond() .withStatusCode(200) .withFile('response.json') .withDelayRange(500, 1500) Logs You will see log entries similar to the following: 14:39:08 INFO i.g.i.s.ResponseServiceImpl - Delaying mock response for GET /example-range-delay by 1000ms 14:39:09 INFO i.g.i.s.ResponseServiceImpl - Serving response data (5 bytes) for URI http://localhost:50203/example-range-delay with status code 200","title":"Performance simulation"},{"location":"performance_simulation/#performance-simulation","text":"Characteristics like response latency can be simulated.","title":"Performance simulation"},{"location":"performance_simulation/#injecting-delays","text":"Delays can be injected via a configuration driven approach or a script driven approach. Delays are specified in milliseconds. The delay controls the time added after any request processing has completed (scripts, plugins etc.). So, if a normal un-delayed request takes 0.05 seconds and a delay of 100ms is added, then the response will be transmitted to the client after 105ms. Delays can be specified as an exact value, or a range. If a range is specified, then a random value (roughly uniformly distributed) will be selected between the minimum and maximum range values.","title":"Injecting delays"},{"location":"performance_simulation/#configuration-driven","text":"Specify the delay section in configuration: For the root resource: # ... response: statusCode: 200 staticFile: \"response.json\" # exactly 1000ms delay delay: exact: 1000 For a specific resource (e.g. OpenAPI or REST plugin): # ... resources: - method: GET path: /example response: statusCode: 200 staticFile: \"response.json\" # delay in range of 500ms-1500ms delay: min: 500 max: 1500","title":"Configuration driven"},{"location":"performance_simulation/#script-driven","text":"If using Scripting , use the withDelay(exactDelay) and withDelayRange(minDelay, maxDelay) methods: For an exact delay: respond() .withStatusCode(200) .withFile('response.json') .withDelay(1000) For a delay within a range: respond() .withStatusCode(200) .withFile('response.json') .withDelayRange(500, 1500)","title":"Script driven"},{"location":"performance_simulation/#logs","text":"You will see log entries similar to the following: 14:39:08 INFO i.g.i.s.ResponseServiceImpl - Delaying mock response for GET /example-range-delay by 1000ms 14:39:09 INFO i.g.i.s.ResponseServiceImpl - Serving response data (5 bytes) for URI http://localhost:50203/example-range-delay with status code 200","title":"Logs"},{"location":"performance_tuning/","text":"Performance tuning Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint. See Benchmarks for representative performance tests. Tuning Some Imposter features have a greater impact than others on the performance of the mock engine. Turning off features Switching off features helps further reduce the memory and CPU requirements of the mock engine. Features that can be switched off include: stores metrics collection See features and usage documentation. Resource matching performance Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance. Response Templating performance Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required. Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests. Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution. Data Capture performance Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data. Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference. Benchmarks See Benchmarks for representative performance tests, including test set up and configuration.","title":"Performance tuning"},{"location":"performance_tuning/#performance-tuning","text":"Imposter supports hundreds to thousands of requests per second, on a single CPU core and small memory footprint. See Benchmarks for representative performance tests.","title":"Performance tuning"},{"location":"performance_tuning/#tuning","text":"Some Imposter features have a greater impact than others on the performance of the mock engine.","title":"Tuning"},{"location":"performance_tuning/#turning-off-features","text":"Switching off features helps further reduce the memory and CPU requirements of the mock engine. Features that can be switched off include: stores metrics collection See features and usage documentation.","title":"Turning off features"},{"location":"performance_tuning/#resource-matching-performance","text":"Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.","title":"Resource matching performance"},{"location":"performance_tuning/#response-templating-performance","text":"Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required. Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests. Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution.","title":"Response Templating performance"},{"location":"performance_tuning/#data-capture-performance","text":"Data capture incurs overhead on response times, depending on the speed of the store implementation used. If using the in-memory store, the performance impact is lower than using an external store. For store providers backed by external datastores, requests will incur a synchronous write to the store when capturing data. Using JsonPath to capture the request body is computationally expensive, as it requires parsing and querying of the request body item rather than just copying a reference.","title":"Data Capture performance"},{"location":"performance_tuning/#benchmarks","text":"See Benchmarks for representative performance tests, including test set up and configuration.","title":"Benchmarks"},{"location":"request_matching/","text":"Advanced request matching You can match resources to requests using attributes such as the HTTP method, path, query string, headers or JSON body. Matching on HTTP method, path, query string or headers See Configuration for details. Matching on JSON body You can match a resource based on a JsonPath query of a JSON request body. Only JSON request bodies are supported for the feature. Specify the match configuration using the requestBody property of a resource. Here you specify a JsonPath expression, and the value it must match. For example: resources: - method: GET path: /example1 requestBody: jsonPath: $.foo value: bar response: statusCode: 204 This will match a request body like this: { \"foo\": \"bar\" } Unmatched or null JsonPath expressions If the result of evaluating the JsonPath expression is null or if the path evaluates to non-existent property in the body, then it is considered null . You can explicitly match a null value, as follows: resources: - method: GET path: /example2 requestBody: jsonPath: $.not-matching-example value: null response: statusCode: 409 Note: the YAML keyword null indicates a null value, not the string literal \"null\" Resource matching performance Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.","title":"Advanced request matching"},{"location":"request_matching/#advanced-request-matching","text":"You can match resources to requests using attributes such as the HTTP method, path, query string, headers or JSON body.","title":"Advanced request matching"},{"location":"request_matching/#matching-on-http-method-path-query-string-or-headers","text":"See Configuration for details.","title":"Matching on HTTP method, path, query string or headers"},{"location":"request_matching/#matching-on-json-body","text":"You can match a resource based on a JsonPath query of a JSON request body. Only JSON request bodies are supported for the feature. Specify the match configuration using the requestBody property of a resource. Here you specify a JsonPath expression, and the value it must match. For example: resources: - method: GET path: /example1 requestBody: jsonPath: $.foo value: bar response: statusCode: 204 This will match a request body like this: { \"foo\": \"bar\" }","title":"Matching on JSON body"},{"location":"request_matching/#unmatched-or-null-jsonpath-expressions","text":"If the result of evaluating the JsonPath expression is null or if the path evaluates to non-existent property in the body, then it is considered null . You can explicitly match a null value, as follows: resources: - method: GET path: /example2 requestBody: jsonPath: $.not-matching-example value: null response: statusCode: 409 Note: the YAML keyword null indicates a null value, not the string literal \"null\"","title":"Unmatched or null JsonPath expressions"},{"location":"request_matching/#resource-matching-performance","text":"Resource matching is typically the fastest method of providing conditional responses. This is the case for request properties such as headers, query parameters, path parameters, path and HTTP method. In the case of using JsonPath to query the request body to conditionally match resources, however, the body must be parsed, which is computationally expensive and will result in lower performance.","title":"Resource matching performance"},{"location":"rest_plugin/","text":"REST plugin Plugin name: rest Plugin class: io.gatehill.imposter.plugin.rest.RestPluginImpl Features Supports RESTful or plain HTTP APIs. Supports arbitrary format static files. Supports optional JSON array responses. Configuration Read the Configuration section to understand how to configure Imposter. Additional context objects None. Example Here is an example configuration file: # simple-example-config.yaml --- plugin: rest path: \"/example\" response: staticFile: example-data.json In this example, we are using a static response file ( example-data.json ) containing the following: { \"hello\": \"world\" } A few things to call out: We\u2019ve defined the endpoint /cats to return the contents of our sample JSON file; in other words an array of cats. We\u2019ve also said that, because the response file is a JSON array, we want to allow querying of individual items by their ID, under the /cats/:id endpoint. This example assumes you\u2019ve named the file containing your JSON array cats.json and that it is in the same directory as the configuration file. Start Imposter with the REST plugin Let's assume your configuration is in the directory: docs/examples/rest/simple . Docker example: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/rest/simple:/opt/imposter/config \\ outofcoffee/imposter-rest Standalone Java example: java -jar distro/rest/build/libs/imposter-rest.jar \\ --configDir ./docs/examples/rest/simple Send an HTTP request to the /example path defined in the configuration file to see the example response: $ curl -v http://localhost:8080/example ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } Once you're finished, stop the server with CTRL+C. Multiple paths We can configure different responses at multiple paths as follows: # multi-response-config.yaml --- plugin: rest contentType: application/json resources: - path: \"/cats/:id\" type: array response: staticFile: cats.json - path: \"/dogs/:id\" type: array response: staticFile: dogs.json Let's return an array of data at each endpoint: # cats.json [ { \"id\": 1, \"name\": \"Fluffy\", \"type\": \"Persian\" }, { \"id\": 2, \"name\": \"Leo\", \"type\": \"Bengal\" } ] # dogs.json [ { \"id\": 1, \"name\": \"Rex\", \"type\": \"Labrador\" }, { \"id\": 2, \"name\": \"Fido\", \"type\": \"Husky\" } ] Start the server: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/rest/multiple:/opt/imposter/config \\ outofcoffee/imposter-rest Send an HTTP request to the /cats/1 path defined in the configuration file to see the first item in the array: $ curl -v http://localhost:8080/cats/1 ... HTTP/1.1 200 OK ... { \"id\": 1, \"name\": \"Fluffy\", \"type\": \"Persian\" } Once you're finished, stop the server with CTRL+C. For more working examples, see: docs/examples/rest plugin/rest/src/test/resources/config Scripted responses (advanced) For simple scenarios, use the staticFile property within the response object in your configuration. For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information.","title":"REST plugin"},{"location":"rest_plugin/#rest-plugin","text":"Plugin name: rest Plugin class: io.gatehill.imposter.plugin.rest.RestPluginImpl","title":"REST plugin"},{"location":"rest_plugin/#features","text":"Supports RESTful or plain HTTP APIs. Supports arbitrary format static files. Supports optional JSON array responses.","title":"Features"},{"location":"rest_plugin/#configuration","text":"Read the Configuration section to understand how to configure Imposter.","title":"Configuration"},{"location":"rest_plugin/#additional-context-objects","text":"None.","title":"Additional context objects"},{"location":"rest_plugin/#example","text":"Here is an example configuration file: # simple-example-config.yaml --- plugin: rest path: \"/example\" response: staticFile: example-data.json In this example, we are using a static response file ( example-data.json ) containing the following: { \"hello\": \"world\" } A few things to call out: We\u2019ve defined the endpoint /cats to return the contents of our sample JSON file; in other words an array of cats. We\u2019ve also said that, because the response file is a JSON array, we want to allow querying of individual items by their ID, under the /cats/:id endpoint. This example assumes you\u2019ve named the file containing your JSON array cats.json and that it is in the same directory as the configuration file.","title":"Example"},{"location":"rest_plugin/#start-imposter-with-the-rest-plugin","text":"Let's assume your configuration is in the directory: docs/examples/rest/simple . Docker example: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/rest/simple:/opt/imposter/config \\ outofcoffee/imposter-rest Standalone Java example: java -jar distro/rest/build/libs/imposter-rest.jar \\ --configDir ./docs/examples/rest/simple Send an HTTP request to the /example path defined in the configuration file to see the example response: $ curl -v http://localhost:8080/example ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } Once you're finished, stop the server with CTRL+C.","title":"Start Imposter with the REST plugin"},{"location":"rest_plugin/#multiple-paths","text":"We can configure different responses at multiple paths as follows: # multi-response-config.yaml --- plugin: rest contentType: application/json resources: - path: \"/cats/:id\" type: array response: staticFile: cats.json - path: \"/dogs/:id\" type: array response: staticFile: dogs.json Let's return an array of data at each endpoint: # cats.json [ { \"id\": 1, \"name\": \"Fluffy\", \"type\": \"Persian\" }, { \"id\": 2, \"name\": \"Leo\", \"type\": \"Bengal\" } ] # dogs.json [ { \"id\": 1, \"name\": \"Rex\", \"type\": \"Labrador\" }, { \"id\": 2, \"name\": \"Fido\", \"type\": \"Husky\" } ] Start the server: docker run --rm -ti -p 8080:8080 \\ -v $PWD/docs/examples/rest/multiple:/opt/imposter/config \\ outofcoffee/imposter-rest Send an HTTP request to the /cats/1 path defined in the configuration file to see the first item in the array: $ curl -v http://localhost:8080/cats/1 ... HTTP/1.1 200 OK ... { \"id\": 1, \"name\": \"Fluffy\", \"type\": \"Persian\" } Once you're finished, stop the server with CTRL+C. For more working examples, see: docs/examples/rest plugin/rest/src/test/resources/config","title":"Multiple paths"},{"location":"rest_plugin/#scripted-responses-advanced","text":"For simple scenarios, use the staticFile property within the response object in your configuration. For more advanced scenarios, you can also control Imposter's responses using JavaScript or Groovy scripts. See the Scripting section for more information.","title":"Scripted responses (advanced)"},{"location":"roadmap/","text":"Roadmap This section lists future ideas for features and improvements. Feel free to submit a suggestion by raising an issue. Features Non-HTTP transports Asynchronous requests (i.e. callbacks) Asynchronous responses Request and response validation against a JSON Schema file (instead of just OpenAPI spec) Improvements HBase Add content type header to HBase response Reuse HBase model classes for JSON serialisation Deprecated The following features are deprecated and will be removed in a future major version. Legacy context.params map - use context.request.queryParams instead Legacy context.request.params map - use context.request.queryParams instead Legacy context.uri map - use context.request.uri instead Request header keys will be lowercased (changing the default of IMPOSTER_NORMALISE_HEADER_KEYS from false to true ) Enabling request and response validation by default","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"This section lists future ideas for features and improvements. Feel free to submit a suggestion by raising an issue.","title":"Roadmap"},{"location":"roadmap/#features","text":"Non-HTTP transports Asynchronous requests (i.e. callbacks) Asynchronous responses Request and response validation against a JSON Schema file (instead of just OpenAPI spec)","title":"Features"},{"location":"roadmap/#improvements","text":"","title":"Improvements"},{"location":"roadmap/#hbase","text":"Add content type header to HBase response Reuse HBase model classes for JSON serialisation","title":"HBase"},{"location":"roadmap/#deprecated","text":"The following features are deprecated and will be removed in a future major version. Legacy context.params map - use context.request.queryParams instead Legacy context.request.params map - use context.request.queryParams instead Legacy context.uri map - use context.request.uri instead Request header keys will be lowercased (changing the default of IMPOSTER_NORMALISE_HEADER_KEYS from false to true ) Enabling request and response validation by default","title":"Deprecated"},{"location":"run_imposter_cli/","text":"Running Imposter with the CLI There are many ways to run Imposter. This section describes using the command line interface (CLI) tool. Other ways to run Imposter Standalone mock server As a Docker container - see Imposter Docker container As a JAR file on the JVM - see Imposter JAR file Embedded in tests Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings CLI Features Start mocks ( imposter up ) Generate mock configuration from OpenAPI files ( imposter scaffold ) Supports all plugins Installation See the full Installation instructions for your system. Prerequisites You must have Docker or a JVM installed. Homebrew If you have Homebrew installed: brew tap gatehill/imposter brew install imposter Shell script Or, use this one liner (macOS and Linux only): curl -L https://raw.githubusercontent.com/gatehill/imposter-cli/main/install/install_imposter.sh | bash - Example $ cd /path/to/config $ imposter up Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running Usage See full usage instructions on Imposter CLI . What's next Learn how to use Imposter with the Configuration guide .","title":"Running Imposter with the CLI"},{"location":"run_imposter_cli/#running-imposter-with-the-cli","text":"There are many ways to run Imposter. This section describes using the command line interface (CLI) tool.","title":"Running Imposter with the CLI"},{"location":"run_imposter_cli/#other-ways-to-run-imposter","text":"","title":"Other ways to run Imposter"},{"location":"run_imposter_cli/#standalone-mock-server","text":"As a Docker container - see Imposter Docker container As a JAR file on the JVM - see Imposter JAR file","title":"Standalone mock server"},{"location":"run_imposter_cli/#embedded-in-tests","text":"Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings","title":"Embedded in tests"},{"location":"run_imposter_cli/#cli-features","text":"Start mocks ( imposter up ) Generate mock configuration from OpenAPI files ( imposter scaffold ) Supports all plugins","title":"CLI Features"},{"location":"run_imposter_cli/#installation","text":"See the full Installation instructions for your system.","title":"Installation"},{"location":"run_imposter_cli/#prerequisites","text":"You must have Docker or a JVM installed.","title":"Prerequisites"},{"location":"run_imposter_cli/#homebrew","text":"If you have Homebrew installed: brew tap gatehill/imposter brew install imposter","title":"Homebrew"},{"location":"run_imposter_cli/#shell-script","text":"Or, use this one liner (macOS and Linux only): curl -L https://raw.githubusercontent.com/gatehill/imposter-cli/main/install/install_imposter.sh | bash -","title":"Shell script"},{"location":"run_imposter_cli/#example","text":"$ cd /path/to/config $ imposter up Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running","title":"Example"},{"location":"run_imposter_cli/#usage","text":"See full usage instructions on Imposter CLI .","title":"Usage"},{"location":"run_imposter_cli/#whats-next","text":"Learn how to use Imposter with the Configuration guide .","title":"What's next"},{"location":"run_imposter_docker/","text":"Running Imposter as a Docker container There are many ways to run Imposter. This section describes how to use the Docker container. Other ways to run Imposter Standalone mock server Using the command line client - see Imposter CLI As a JAR file on the JVM - see Imposter JAR file Embedded in tests Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings Docker Image Features Start mocks Supports all plugins Run Prerequisites You must have Docker installed. The easiest way to get started is to use an Imposter Docker container, such as: docker run -ti -p 8080:8080 outofcoffee/imposter-rest [args] Docker images The following images are available: Image Docker Hub link Notes openapi outofcoffee/imposter-openapi rest outofcoffee/imposter-rest hbase outofcoffee/imposter-hbase sfdc outofcoffee/imposter-sfdc all outofcoffee/imposter Supports all plugins You can also use the these images to create your own custom images with embedded configuration. Run container Run using Docker: docker run -ti -p 8080:8080 \\ -v /path/to/config:/opt/imposter/config \\ outofcoffee/imposter-rest [args] ...ensuring that you choose the right image for the plugin you wish to use. Example $ docker run --rm -it -p 8080:8080 -v $PWD/example-api:/opt/imposter/config outofcoffee/imposter-rest Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running Usage See full usage instructions . What's next Learn how to use Imposter with the Configuration guide .","title":"Running Imposter as a Docker container"},{"location":"run_imposter_docker/#running-imposter-as-a-docker-container","text":"There are many ways to run Imposter. This section describes how to use the Docker container.","title":"Running Imposter as a Docker container"},{"location":"run_imposter_docker/#other-ways-to-run-imposter","text":"","title":"Other ways to run Imposter"},{"location":"run_imposter_docker/#standalone-mock-server","text":"Using the command line client - see Imposter CLI As a JAR file on the JVM - see Imposter JAR file","title":"Standalone mock server"},{"location":"run_imposter_docker/#embedded-in-tests","text":"Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings","title":"Embedded in tests"},{"location":"run_imposter_docker/#docker-image-features","text":"Start mocks Supports all plugins","title":"Docker Image Features"},{"location":"run_imposter_docker/#run","text":"","title":"Run"},{"location":"run_imposter_docker/#prerequisites","text":"You must have Docker installed. The easiest way to get started is to use an Imposter Docker container, such as: docker run -ti -p 8080:8080 outofcoffee/imposter-rest [args]","title":"Prerequisites"},{"location":"run_imposter_docker/#docker-images","text":"The following images are available: Image Docker Hub link Notes openapi outofcoffee/imposter-openapi rest outofcoffee/imposter-rest hbase outofcoffee/imposter-hbase sfdc outofcoffee/imposter-sfdc all outofcoffee/imposter Supports all plugins You can also use the these images to create your own custom images with embedded configuration.","title":"Docker images"},{"location":"run_imposter_docker/#run-container","text":"Run using Docker: docker run -ti -p 8080:8080 \\ -v /path/to/config:/opt/imposter/config \\ outofcoffee/imposter-rest [args] ...ensuring that you choose the right image for the plugin you wish to use.","title":"Run container"},{"location":"run_imposter_docker/#example","text":"$ docker run --rm -it -p 8080:8080 -v $PWD/example-api:/opt/imposter/config outofcoffee/imposter-rest Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running","title":"Example"},{"location":"run_imposter_docker/#usage","text":"See full usage instructions .","title":"Usage"},{"location":"run_imposter_docker/#whats-next","text":"Learn how to use Imposter with the Configuration guide .","title":"What's next"},{"location":"run_imposter_jar/","text":"Running Imposter as a JAR on the JVM There are many ways to run Imposter. This section describes how to use a JAR file on the JVM. Other ways to run Imposter Standalone mock server Using the command line client - see Imposter CLI As a Docker container - see Imposter Docker container Embedded in tests Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings JAR File Features Start mocks Supports all plugins Note: if you want to embed Imposter in your JUnit tests, see JVM bindings instead. Run Prerequisites You must have a JVM installed. Java 8, 11 and 15 have been confirmed as compatible. Others may also be, but are not currently tested. Run the JAR as follows: java -jar distro/all/build/libs/imposter-all.jar \\ --plugin <plugin name> \\ --configDir <config dir> \\ [args] ...ensuring that you choose the right plugin you wish to use, for example: java -jar distro/all/build/libs/imposter-all.jar \\ --plugin rest \\ --configDir /path/to/config \\ [args] Example $ java -jar ./imposter-all.jar --plugin rest --configDir ./example-api Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running Usage See full usage instructions . What's next Learn how to use Imposter with the Configuration guide .","title":"Running Imposter as a JAR on the JVM"},{"location":"run_imposter_jar/#running-imposter-as-a-jar-on-the-jvm","text":"There are many ways to run Imposter. This section describes how to use a JAR file on the JVM.","title":"Running Imposter as a JAR on the JVM"},{"location":"run_imposter_jar/#other-ways-to-run-imposter","text":"","title":"Other ways to run Imposter"},{"location":"run_imposter_jar/#standalone-mock-server","text":"Using the command line client - see Imposter CLI As a Docker container - see Imposter Docker container","title":"Standalone mock server"},{"location":"run_imposter_jar/#embedded-in-tests","text":"Embedded within your Java/Kotlin/Scala/JVM unit tests - see JVM bindings Embedded within your JavaScript/Node.js unit tests - see JavaScript bindings","title":"Embedded in tests"},{"location":"run_imposter_jar/#jar-file-features","text":"Start mocks Supports all plugins Note: if you want to embed Imposter in your JUnit tests, see JVM bindings instead.","title":"JAR File Features"},{"location":"run_imposter_jar/#run","text":"","title":"Run"},{"location":"run_imposter_jar/#prerequisites","text":"You must have a JVM installed. Java 8, 11 and 15 have been confirmed as compatible. Others may also be, but are not currently tested. Run the JAR as follows: java -jar distro/all/build/libs/imposter-all.jar \\ --plugin <plugin name> \\ --configDir <config dir> \\ [args] ...ensuring that you choose the right plugin you wish to use, for example: java -jar distro/all/build/libs/imposter-all.jar \\ --plugin rest \\ --configDir /path/to/config \\ [args]","title":"Prerequisites"},{"location":"run_imposter_jar/#example","text":"$ java -jar ./imposter-all.jar --plugin rest --configDir ./example-api Starting server on port 8080... Parsing configuration file: someapi-config.yaml ... Mock server is up and running","title":"Example"},{"location":"run_imposter_jar/#usage","text":"See full usage instructions .","title":"Usage"},{"location":"run_imposter_jar/#whats-next","text":"Learn how to use Imposter with the Configuration guide .","title":"What's next"},{"location":"scripting/","text":"Scripted responses Read this section to learn how to use scripts to configure Imposter's responses. You can control Imposter's responses using JavaScript or Groovy scripts. (If you choose Groovy , you can of course write plain Java in your scripts as well). Example Here's an example configuration file that uses a script: # scripted-example-config.yaml --- plugin: rest path: \"/example-two\" response: scriptFile: example.groovy ...and here's the corresponding script ( example.groovy ): if (context.request.queryParams.action == 'create') { respond() .withStatusCode(201) .skipDefaultBehaviour() } We will explain this syntax later, in the ResponseBehaviour object section. For now, it's enough to know that the example above causes the mock server to respond with HTTP status code 201 if the value of the action parameter in the request is create . For example: HTTP GET http://localhost:8080/example-two?action=create ... 201 Created Tip: The queryParams object used in the script is just a map of the request parameters, so you can use either params.yourParamName or params['yourParamName'] syntax to access its members. Another example Here's a more sophisticated example script: switch (context.request.queryParams.action) { case 'create': // HTTP Status-Code 201: Created. respond() .withStatusCode(201) .skipDefaultBehaviour() break case 'fetch': // use a static response file and the default plugin behaviour respond() .withFile('example-data.json') .usingDefaultBehaviour() break default: // default to bad request respond() .withStatusCode(400) .skipDefaultBehaviour() break } In this example, the script causes the mock server to respond with HTTP status codes 200, 201 or 400 depending on the value of the action parameter in the request. For example: HTTP GET http://localhost:8080/example-two?action=fetch ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } In the case of action=fetch , the script causes the mock server to use the content of the static file static-data.json to serve the response. And: HTTP GET http://localhost:8080/example-two?action=foo ... 400 Bad Request In the default case, the script causes the mock server to return an HTTP 400 response, as shown above. There are many other script objects you could use in order to decide what to return. For example, your script might use the request method (GET, POST, PUT, DELETE etc.) or other request attributes. Script objects In order to help you determine what action to take, Imposter makes certain objects available to your scripts. Object Description context Parent object for accessing request properties config The plugin configuration for the current request env A map of environment variables, such as { \"MY_VAR\": \"abc\", \"VAR2\": \"def\" } logger Logger, supporting levels such as info(String) , warn(String) etc. Context object The context object is available to your scripts. It holds things you might like to interrogate, like the request object. Property Description Example request The HTTP request. See Request object. Note: Certain plugins will add additional properties to the context . For example, the hbase plugin provides a tableName object, which you can use to determine the HBase table for the request being served. Request object The request object is available on the context . It provides access to request parameters, method, URI etc. Property Description Example path The path of the request. \"/example\" method The HTTP method of the request. \"GET\" pathParams A map containing the request path parameters. { \"productCode\": \"abc\", \"foo\": \"bar\" } queryParams A map containing the request query parameters. { \"limit\": \"10\", \"foo\": \"bar\" } uri The absolute URI of the request. \"http://example.com?foo=bar&baz=qux\" headers A map containing the request headers. { \"X-Example\": \"ABC123\", \"Content-Type\": \"text/plain\" } normalisedHeaders A map containing the request headers with all keys in lowercase. { \"x-example\": \"ABC123\", \"content-type\": \"text/plain\" } body A string containing the request body. \"Hello world.\" Note: keys are always lowercase in normalisedHeaders , regardless of the request header casing. This aids script portability, avoiding case-sensitivity for header keys. Response object Your scripts have access to the methods on io.gatehill.imposter.script.MutableResponseBehaviour . The response behaviour object provides a number of methods to enable you to control the response: Method Plugin(s) Description withStatusCode(int) all Set the HTTP status code for the response. withFile(String) all Respond with the content of a static file. Also see template . withData(String) all Respond with the literal content of a string. Also see template . withExampleName(String) openapi Respond with the OpenAPI specification example with a given name. withHeader(String, String) all Set a response header. withEmpty() all Respond with empty content, or no records. usingDefaultBehaviour() all Use the plugin's default behaviour to respond. skipDefaultBehaviour() all Skip the plugin's default behaviour when responding. and() all Syntactic sugar to improve readability of respond statements. template() all Treat the response file or data as a template with placeholders. You structure your response behaviours like so: respond() // ... behaviours go here For example: respond() .withStatusCode(201) .skipDefaultBehaviour() Or: respond() .withFile('static-data.json') .usingDefaultBehaviour() Returning data from a script As we have seen above, to return data when using a script, you specify a response file. More specifically, to specify which response file to use, you can either: set the staticFile property within the response object in your configuration, which will be treated as the default, or explicitly call the withFile(String) method in your script. Here's an example of the static file approach: # file-example-config.yaml --- plugin: rest path: \"/scripted\" contentType: application/json response: scriptFile: example.groovy staticFile: example-data.json Here, the response file example-data.json will be used, unless the script invokes the withFile(String) method with a different filename. In order for the mock server to return the response file in an appropriate format, the plugin must be allowed to process it. That means you should not call skipDefaultBehaviour() unless you want to skip using a response file (e.g. if you want to send an error code back or a response without a body). Whilst not required, your script could invoke usingDefaultBehaviour() for readability to indicate that you want the plugin to handle the response file for you. See the rest plugin tests for a working example. To this end, the following blocks are semantically identical: respond() .withFile('static-data.json') .usingDefaultBehaviour() and: respond().withFile('static-data.json') Setting response headers You can set response headers using the withHeader(String, String) method. respond().withHeader('X-Custom-Header', 'example value') Returning raw data You can return raw data using the withData(String) method. respond().withData('{ \"someKey\": \"someValue\" }') Returning a specific example When using the OpenAPI plugin , you can return a specific named example from the specification using the withExampleName(String) method. respond().withExampleName('example1') This selects the example from the OpenAPI examples section for the API response. Tip for Groovy users Groovy users can also use this special block syntax, for improved readability: respond { // behaviours go here } For example: respond { withStatusCode 201 and() usingDefaultBehaviour() }","title":"Scripting"},{"location":"scripting/#scripted-responses","text":"Read this section to learn how to use scripts to configure Imposter's responses. You can control Imposter's responses using JavaScript or Groovy scripts. (If you choose Groovy , you can of course write plain Java in your scripts as well).","title":"Scripted responses"},{"location":"scripting/#example","text":"Here's an example configuration file that uses a script: # scripted-example-config.yaml --- plugin: rest path: \"/example-two\" response: scriptFile: example.groovy ...and here's the corresponding script ( example.groovy ): if (context.request.queryParams.action == 'create') { respond() .withStatusCode(201) .skipDefaultBehaviour() } We will explain this syntax later, in the ResponseBehaviour object section. For now, it's enough to know that the example above causes the mock server to respond with HTTP status code 201 if the value of the action parameter in the request is create . For example: HTTP GET http://localhost:8080/example-two?action=create ... 201 Created Tip: The queryParams object used in the script is just a map of the request parameters, so you can use either params.yourParamName or params['yourParamName'] syntax to access its members.","title":"Example"},{"location":"scripting/#another-example","text":"Here's a more sophisticated example script: switch (context.request.queryParams.action) { case 'create': // HTTP Status-Code 201: Created. respond() .withStatusCode(201) .skipDefaultBehaviour() break case 'fetch': // use a static response file and the default plugin behaviour respond() .withFile('example-data.json') .usingDefaultBehaviour() break default: // default to bad request respond() .withStatusCode(400) .skipDefaultBehaviour() break } In this example, the script causes the mock server to respond with HTTP status codes 200, 201 or 400 depending on the value of the action parameter in the request. For example: HTTP GET http://localhost:8080/example-two?action=fetch ... HTTP/1.1 200 OK ... { \"hello\": \"world\" } In the case of action=fetch , the script causes the mock server to use the content of the static file static-data.json to serve the response. And: HTTP GET http://localhost:8080/example-two?action=foo ... 400 Bad Request In the default case, the script causes the mock server to return an HTTP 400 response, as shown above. There are many other script objects you could use in order to decide what to return. For example, your script might use the request method (GET, POST, PUT, DELETE etc.) or other request attributes.","title":"Another example"},{"location":"scripting/#script-objects","text":"In order to help you determine what action to take, Imposter makes certain objects available to your scripts. Object Description context Parent object for accessing request properties config The plugin configuration for the current request env A map of environment variables, such as { \"MY_VAR\": \"abc\", \"VAR2\": \"def\" } logger Logger, supporting levels such as info(String) , warn(String) etc.","title":"Script objects"},{"location":"scripting/#context-object","text":"The context object is available to your scripts. It holds things you might like to interrogate, like the request object. Property Description Example request The HTTP request. See Request object. Note: Certain plugins will add additional properties to the context . For example, the hbase plugin provides a tableName object, which you can use to determine the HBase table for the request being served.","title":"Context object"},{"location":"scripting/#request-object","text":"The request object is available on the context . It provides access to request parameters, method, URI etc. Property Description Example path The path of the request. \"/example\" method The HTTP method of the request. \"GET\" pathParams A map containing the request path parameters. { \"productCode\": \"abc\", \"foo\": \"bar\" } queryParams A map containing the request query parameters. { \"limit\": \"10\", \"foo\": \"bar\" } uri The absolute URI of the request. \"http://example.com?foo=bar&baz=qux\" headers A map containing the request headers. { \"X-Example\": \"ABC123\", \"Content-Type\": \"text/plain\" } normalisedHeaders A map containing the request headers with all keys in lowercase. { \"x-example\": \"ABC123\", \"content-type\": \"text/plain\" } body A string containing the request body. \"Hello world.\" Note: keys are always lowercase in normalisedHeaders , regardless of the request header casing. This aids script portability, avoiding case-sensitivity for header keys.","title":"Request object"},{"location":"scripting/#response-object","text":"Your scripts have access to the methods on io.gatehill.imposter.script.MutableResponseBehaviour . The response behaviour object provides a number of methods to enable you to control the response: Method Plugin(s) Description withStatusCode(int) all Set the HTTP status code for the response. withFile(String) all Respond with the content of a static file. Also see template . withData(String) all Respond with the literal content of a string. Also see template . withExampleName(String) openapi Respond with the OpenAPI specification example with a given name. withHeader(String, String) all Set a response header. withEmpty() all Respond with empty content, or no records. usingDefaultBehaviour() all Use the plugin's default behaviour to respond. skipDefaultBehaviour() all Skip the plugin's default behaviour when responding. and() all Syntactic sugar to improve readability of respond statements. template() all Treat the response file or data as a template with placeholders. You structure your response behaviours like so: respond() // ... behaviours go here For example: respond() .withStatusCode(201) .skipDefaultBehaviour() Or: respond() .withFile('static-data.json') .usingDefaultBehaviour()","title":"Response object"},{"location":"scripting/#returning-data-from-a-script","text":"As we have seen above, to return data when using a script, you specify a response file. More specifically, to specify which response file to use, you can either: set the staticFile property within the response object in your configuration, which will be treated as the default, or explicitly call the withFile(String) method in your script. Here's an example of the static file approach: # file-example-config.yaml --- plugin: rest path: \"/scripted\" contentType: application/json response: scriptFile: example.groovy staticFile: example-data.json Here, the response file example-data.json will be used, unless the script invokes the withFile(String) method with a different filename. In order for the mock server to return the response file in an appropriate format, the plugin must be allowed to process it. That means you should not call skipDefaultBehaviour() unless you want to skip using a response file (e.g. if you want to send an error code back or a response without a body). Whilst not required, your script could invoke usingDefaultBehaviour() for readability to indicate that you want the plugin to handle the response file for you. See the rest plugin tests for a working example. To this end, the following blocks are semantically identical: respond() .withFile('static-data.json') .usingDefaultBehaviour() and: respond().withFile('static-data.json')","title":"Returning data from a script"},{"location":"scripting/#setting-response-headers","text":"You can set response headers using the withHeader(String, String) method. respond().withHeader('X-Custom-Header', 'example value')","title":"Setting response headers"},{"location":"scripting/#returning-raw-data","text":"You can return raw data using the withData(String) method. respond().withData('{ \"someKey\": \"someValue\" }')","title":"Returning raw data"},{"location":"scripting/#returning-a-specific-example","text":"When using the OpenAPI plugin , you can return a specific named example from the specification using the withExampleName(String) method. respond().withExampleName('example1') This selects the example from the OpenAPI examples section for the API response. Tip for Groovy users Groovy users can also use this special block syntax, for improved readability: respond { // behaviours go here } For example: respond { withStatusCode 201 and() usingDefaultBehaviour() }","title":"Returning a specific example"},{"location":"security/","text":"Security This section covers Imposter security. Topics include transport layer security (i.e. HTTPS) and authentication. There are two primary approaches for adding TLS and authentication: Using Imposter's embedded HTTP server Using a reverse proxy or load balancer in front of Imposter This section covers the first approach - using the embedded HTTP server. Using a reverse proxy or load balancer is a larger topic outside the scope of this documentation. TLS/SSL You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options. Read more about how to enable TLS/SSL . Authentication Imposter can require specific header values to authenticate incoming HTTP requests. To do this, use the security section within the plugin configuration file. Note: this example uses the OpenAPI plugin but the same configuration works with other plugins as well. # example-config.yaml --- plugin: openapi specFile: petstore.yaml security: # no requests permitted by default default: Deny # only requests meeting these conditions are permitted conditions: - effect: Permit requestHeaders: Authorization: s3cr3t Concepts and terminology Authentication configuration uses the following terms: Term Meaning Examples Condition A property of the request, such as the presence of a specific header value. Authorization header value foo Operator How the condition is matched. EqualTo , NotEqualTo Effect The impact of the condition on the request, such as it being denied. Permit , Deny The first important concept is the Default Effect . This is the effect that applies to all requests in the absence of a more specific condition. It is good practice to adhere the principle of least privilege. You can achieve this by setting the default effect to Deny , and then adding specific conditions that permit access. security: # no requests permitted by default default: Deny This configuration will cause all responses from Imposter to have an HTTP 401 Unauthorized status. Once you have configured the default effect, you typically add Conditions to your security configuration, optionally specifying an Operator . security: # no requests permitted by default default: Deny # only requests meeting these conditions are permitted conditions: - effect: Permit requestHeaders: Authorization: s3cr3t In this example, Imposter only permits requests that have the following HTTP request header: Authorization: s3cr3t Imposter will respond to these requests as normal, but respond to those without this specific header value with HTTP 401 Unauthorized status. The header name and value is arbitrary - you do not have to use the Authorization header. For example, you could specify: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t Supported conditions Imposter supports the following conditions: Condition Meaning Type Example queryParams Request query parameters. Map of String:String { \"limit\": \"1\" } requestHeaders Request headers. Map of String:String { \"Authorization\": \"foo\" } Here's an example showing all conditions: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t - effect: Deny requestHeaders: X-Forwarded-For: value: 1.2.3.4 operator: NotEqualTo - effect: Permit queryParams: apiKey: value: opensesame operator: EqualTo - effect: Deny queryParams: apiKey: someblockedkey Simple and extended form For each condition you can use the simple form ( key: value ) or extended form, which allows customisation of matching behaviour. The simple form for conditions is as follows: - effect: Permit queryParams: example: foo If you want to control the logical operator you can use the extended form as follows: - effect: Permit queryParams: example: value: foo operator: NotEqualTo By default, conditions are matched using the EqualTo operator. Here, the value of the example query parameter is specified as a child property named value . The operator is also specified in this form, such as EqualTo or NotEqualTo . Combining conditions The presence of more than one header in a condition requires all header values match in order for the condition to be satisfied. # requests are permitted if both headers match conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t X-Another-Example: someothervalue If you need different effects, use multiple conditions, as follows: # requests are permitted if both (1) and (2) are satisfied conditions: # (1) this header must match - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t # (2) this header must not match - effect: Deny requestHeaders: X-Another-Example: someothervalue Externalising values to environment variables You can use environment variables to avoid including secrets in your configuration files. For example: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: \"${env.API_KEY}\" Security and the status endpoint Imposter has a status endpoint /system/status that is useful as a healthcheck. When you apply a security policy with a default effect of Deny , it also applies to the status endpoint. This will cause requests to /system/status to be denied with HTTP 401 status. In cases where you want to permit traffic to the status endpoint without authentication, you can add the following configuration to your OpenAPI plugin or REST plugin configuration: # example-config.yaml --- plugin: openapi specFile: petstore.yaml security: # no requests permitted by default default: Deny resources: # always permit status endpoint - method: GET path: /system/status security: default: Permit More examples See the docs/examples directory for working sample configurations, such as: Simple authentication Extended authentication","title":"Security"},{"location":"security/#security","text":"This section covers Imposter security. Topics include transport layer security (i.e. HTTPS) and authentication. There are two primary approaches for adding TLS and authentication: Using Imposter's embedded HTTP server Using a reverse proxy or load balancer in front of Imposter This section covers the first approach - using the embedded HTTP server. Using a reverse proxy or load balancer is a larger topic outside the scope of this documentation.","title":"Security"},{"location":"security/#tlsssl","text":"You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options. Read more about how to enable TLS/SSL .","title":"TLS/SSL"},{"location":"security/#authentication","text":"Imposter can require specific header values to authenticate incoming HTTP requests. To do this, use the security section within the plugin configuration file. Note: this example uses the OpenAPI plugin but the same configuration works with other plugins as well. # example-config.yaml --- plugin: openapi specFile: petstore.yaml security: # no requests permitted by default default: Deny # only requests meeting these conditions are permitted conditions: - effect: Permit requestHeaders: Authorization: s3cr3t","title":"Authentication"},{"location":"security/#concepts-and-terminology","text":"Authentication configuration uses the following terms: Term Meaning Examples Condition A property of the request, such as the presence of a specific header value. Authorization header value foo Operator How the condition is matched. EqualTo , NotEqualTo Effect The impact of the condition on the request, such as it being denied. Permit , Deny The first important concept is the Default Effect . This is the effect that applies to all requests in the absence of a more specific condition. It is good practice to adhere the principle of least privilege. You can achieve this by setting the default effect to Deny , and then adding specific conditions that permit access. security: # no requests permitted by default default: Deny This configuration will cause all responses from Imposter to have an HTTP 401 Unauthorized status. Once you have configured the default effect, you typically add Conditions to your security configuration, optionally specifying an Operator . security: # no requests permitted by default default: Deny # only requests meeting these conditions are permitted conditions: - effect: Permit requestHeaders: Authorization: s3cr3t In this example, Imposter only permits requests that have the following HTTP request header: Authorization: s3cr3t Imposter will respond to these requests as normal, but respond to those without this specific header value with HTTP 401 Unauthorized status. The header name and value is arbitrary - you do not have to use the Authorization header. For example, you could specify: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t","title":"Concepts and terminology"},{"location":"security/#supported-conditions","text":"Imposter supports the following conditions: Condition Meaning Type Example queryParams Request query parameters. Map of String:String { \"limit\": \"1\" } requestHeaders Request headers. Map of String:String { \"Authorization\": \"foo\" } Here's an example showing all conditions: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t - effect: Deny requestHeaders: X-Forwarded-For: value: 1.2.3.4 operator: NotEqualTo - effect: Permit queryParams: apiKey: value: opensesame operator: EqualTo - effect: Deny queryParams: apiKey: someblockedkey","title":"Supported conditions"},{"location":"security/#simple-and-extended-form","text":"For each condition you can use the simple form ( key: value ) or extended form, which allows customisation of matching behaviour. The simple form for conditions is as follows: - effect: Permit queryParams: example: foo If you want to control the logical operator you can use the extended form as follows: - effect: Permit queryParams: example: value: foo operator: NotEqualTo By default, conditions are matched using the EqualTo operator. Here, the value of the example query parameter is specified as a child property named value . The operator is also specified in this form, such as EqualTo or NotEqualTo .","title":"Simple and extended form"},{"location":"security/#combining-conditions","text":"The presence of more than one header in a condition requires all header values match in order for the condition to be satisfied. # requests are permitted if both headers match conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t X-Another-Example: someothervalue If you need different effects, use multiple conditions, as follows: # requests are permitted if both (1) and (2) are satisfied conditions: # (1) this header must match - effect: Permit requestHeaders: X-Custom-Api-Key: s3cr3t # (2) this header must not match - effect: Deny requestHeaders: X-Another-Example: someothervalue","title":"Combining conditions"},{"location":"security/#externalising-values-to-environment-variables","text":"You can use environment variables to avoid including secrets in your configuration files. For example: conditions: - effect: Permit requestHeaders: X-Custom-Api-Key: \"${env.API_KEY}\"","title":"Externalising values to environment variables"},{"location":"security/#security-and-the-status-endpoint","text":"Imposter has a status endpoint /system/status that is useful as a healthcheck. When you apply a security policy with a default effect of Deny , it also applies to the status endpoint. This will cause requests to /system/status to be denied with HTTP 401 status. In cases where you want to permit traffic to the status endpoint without authentication, you can add the following configuration to your OpenAPI plugin or REST plugin configuration: # example-config.yaml --- plugin: openapi specFile: petstore.yaml security: # no requests permitted by default default: Deny resources: # always permit status endpoint - method: GET path: /system/status security: default: Permit","title":"Security and the status endpoint"},{"location":"security/#more-examples","text":"See the docs/examples directory for working sample configurations, such as: Simple authentication Extended authentication","title":"More examples"},{"location":"sfdc_plugin/","text":"SFDC (Salesforce) plugin Plugin name: sfdc Plugin class: io.gatehill.imposter.plugin.sfdc.SfdcPluginImpl Features Basic Salesforce mock implementation. Non-persistent SObject creation. Non-persistent SObject update. SObject retrieval by ID. Dummy SOQL queries. Configuration Read the Configuration section to understand how to configure Imposter. Additional context objects None. Using the plugin Note: Clients interacting with this plugin often require TLS/SSL to be enabled. If this is the case for your client, ensure that you use an https:// scheme for accessing the mock server. See the TLS/SSL section in the TLS/SSL section for more details. Note: Typically, an OAuth2 login step precedes interactions with the SFDC API. As part of this, the mock server is required to return an instance_url to the client. Imposter uses the 'server URL', which is described in the Usage section. Example For working examples, see: plugin/sfdc/src/test/resources/config Let's assume your configuration is in a folder named config . Docker example: docker run -ti -p 8080:8080 \\ -v $PWD/config:/opt/imposter/config \\ outofcoffee/imposter-sfdc \\ --serverUrl http://localhost:8080 Standalone Java example: java -jar distro/sfdc/build/libs/imposter-sfdc.jar \\ --configDir ./config \\ --serverUrl http://localhost:8080 This starts a mock server using the SFDC plugin. Responses are served based on the configuration files inside the config folder. Using the example above, you can connect a Salesforce client, such as ForceApi , to http://localhost:8080/ to interact with the API. In this example, you can interact with the Account SObject, as defined in sfdc-plugin-config.json and sfdc-plugin-data.json .","title":"SFDC (Salesforce) plugin"},{"location":"sfdc_plugin/#sfdc-salesforce-plugin","text":"Plugin name: sfdc Plugin class: io.gatehill.imposter.plugin.sfdc.SfdcPluginImpl","title":"SFDC (Salesforce) plugin"},{"location":"sfdc_plugin/#features","text":"Basic Salesforce mock implementation. Non-persistent SObject creation. Non-persistent SObject update. SObject retrieval by ID. Dummy SOQL queries.","title":"Features"},{"location":"sfdc_plugin/#configuration","text":"Read the Configuration section to understand how to configure Imposter.","title":"Configuration"},{"location":"sfdc_plugin/#additional-context-objects","text":"None.","title":"Additional context objects"},{"location":"sfdc_plugin/#using-the-plugin","text":"Note: Clients interacting with this plugin often require TLS/SSL to be enabled. If this is the case for your client, ensure that you use an https:// scheme for accessing the mock server. See the TLS/SSL section in the TLS/SSL section for more details. Note: Typically, an OAuth2 login step precedes interactions with the SFDC API. As part of this, the mock server is required to return an instance_url to the client. Imposter uses the 'server URL', which is described in the Usage section.","title":"Using the plugin"},{"location":"sfdc_plugin/#example","text":"For working examples, see: plugin/sfdc/src/test/resources/config Let's assume your configuration is in a folder named config . Docker example: docker run -ti -p 8080:8080 \\ -v $PWD/config:/opt/imposter/config \\ outofcoffee/imposter-sfdc \\ --serverUrl http://localhost:8080 Standalone Java example: java -jar distro/sfdc/build/libs/imposter-sfdc.jar \\ --configDir ./config \\ --serverUrl http://localhost:8080 This starts a mock server using the SFDC plugin. Responses are served based on the configuration files inside the config folder. Using the example above, you can connect a Salesforce client, such as ForceApi , to http://localhost:8080/ to interact with the API. In this example, you can interact with the Account SObject, as defined in sfdc-plugin-config.json and sfdc-plugin-data.json .","title":"Example"},{"location":"stores/","text":"Stores Imposter allows you to store data for use later. Benefits: use data from a request in a current or future response store the data sent to a mock for later retrieval/verification set up or seed test data before a mock is used capture data (headers, body etc.) for use by a script return stored data in a response template Summary You can access Stores via an object in scripts , named stores , and the /system/store REST API. Using stores in scripts Here is an example of using the stores object in your scripts. var exampleStore = stores.open('example'); // save the value of the 'foo' query parameter to the store exampleStore.save('foo', context.request.queryParams.foo); // ...in some other request, later var previousFoo = exampleStore.load('foo'); respond() .withStatusCode(200) .withData(previousFoo); Stores also support deletion: exampleStore.delete('example'); and retrieving all data: var storeData = exampleStore.loadAll(); logger.info('foo=' + storeData.foo); logger.info('bar=' + storeData.bar); You can check for the presence of an item by key: if (exampleStore.hasItemWithKey('example')) { // ... there is an item with the key 'example' } The Stores API You can also retrieve or save data to a store through the /system/store API. This can be useful for tests to verify what was sent to a mock: $ curl http://localhost:8080/system/store/test/foo ada In this example, imagine the item foo in the test store was set to the value ada by a previous request or script (see above). You can also set data via this API: $ curl -XPUT --data 'ada' http://localhost:8080/system/store/test/foo Your scripts can now use the data in the store. This can be useful for test data setup/seeding. You can retrieve all the items in a store: $ curl http://localhost:8080/system/store/test { \"foo\": \"ada\", \"bar\": \"baz\" } You can delete items in a store: $ curl -XDELETE http://localhost:8080/system/store/test/foo This deletes the foo item from the test store. You can delete an entire store and all of its data: $ curl -XDELETE http://localhost:8080/system/store/test This deletes the whole test store and all its data. You can set multiple items at once via a POST to the store resource: $ curl -XPOST http://localhost:8080/system/store/test --data '{ \"foo\": \"bar\", \"baz\": \"qux\" }' Environment variables The following environment variables are supported: Variable name Purpose Example(s) IMPOSTER_STORE_MODULE Sets the store implementation (see Store implementations section). io.gatehill.imposter.store.redis.RedisStoreModule IMPOSTER_STORE_KEY_PREFIX Sets an optional prefix for all keys in the store, like a namespace. A prefix of foo would result in the key bar being stored as foo.bar Request scoped store There is a special request-scoped store, named request , which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request. The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template , but you don't need to persist it for later use. Preloading (pre-populating) data into a store You can preload data into a store when Imposter starts. To do this, use the system.stores.preloadFile or system.stores.preloadData key in a configuration file. Preloading from file Typically, you will provide the data in a JSON file, and use the preloadFile key: plugin: rest system: stores: # this store is preloaded from file example: preloadFile: initial-data.json In the above example, the contents of the file initial-data.json will be loaded into the store named 'example'. This file contains a JSON object, such as the following: { \"foo\": \"bar\", \"baz\": { \"qux\": \"corge\" } } Note that you can store child objects, but the top level keys must always be a string. Preloading from inline data If you have a small amount of data, or you don't want to use a separate file, you can provide the preload data inline within a configuration file using the preloadData key: plugin: rest system: stores: # this store is preloaded from inline data example: preloadData: foo: bar baz: { \"qux\": \"corge\" } In the above example, the items under preloadData block will be loaded into the store named 'example'. You must provide an object with key/value pairs, such as that shown above, or in the JSON file below. Top level keys must always be a string. Store implementations Different store implementations exist: In memory store (default) Redis store","title":"Stores"},{"location":"stores/#stores","text":"Imposter allows you to store data for use later. Benefits: use data from a request in a current or future response store the data sent to a mock for later retrieval/verification set up or seed test data before a mock is used capture data (headers, body etc.) for use by a script return stored data in a response template","title":"Stores"},{"location":"stores/#summary","text":"You can access Stores via an object in scripts , named stores , and the /system/store REST API.","title":"Summary"},{"location":"stores/#using-stores-in-scripts","text":"Here is an example of using the stores object in your scripts. var exampleStore = stores.open('example'); // save the value of the 'foo' query parameter to the store exampleStore.save('foo', context.request.queryParams.foo); // ...in some other request, later var previousFoo = exampleStore.load('foo'); respond() .withStatusCode(200) .withData(previousFoo); Stores also support deletion: exampleStore.delete('example'); and retrieving all data: var storeData = exampleStore.loadAll(); logger.info('foo=' + storeData.foo); logger.info('bar=' + storeData.bar); You can check for the presence of an item by key: if (exampleStore.hasItemWithKey('example')) { // ... there is an item with the key 'example' }","title":"Using stores in scripts"},{"location":"stores/#the-stores-api","text":"You can also retrieve or save data to a store through the /system/store API. This can be useful for tests to verify what was sent to a mock: $ curl http://localhost:8080/system/store/test/foo ada In this example, imagine the item foo in the test store was set to the value ada by a previous request or script (see above). You can also set data via this API: $ curl -XPUT --data 'ada' http://localhost:8080/system/store/test/foo Your scripts can now use the data in the store. This can be useful for test data setup/seeding. You can retrieve all the items in a store: $ curl http://localhost:8080/system/store/test { \"foo\": \"ada\", \"bar\": \"baz\" } You can delete items in a store: $ curl -XDELETE http://localhost:8080/system/store/test/foo This deletes the foo item from the test store. You can delete an entire store and all of its data: $ curl -XDELETE http://localhost:8080/system/store/test This deletes the whole test store and all its data. You can set multiple items at once via a POST to the store resource: $ curl -XPOST http://localhost:8080/system/store/test --data '{ \"foo\": \"bar\", \"baz\": \"qux\" }'","title":"The Stores API"},{"location":"stores/#environment-variables","text":"The following environment variables are supported: Variable name Purpose Example(s) IMPOSTER_STORE_MODULE Sets the store implementation (see Store implementations section). io.gatehill.imposter.store.redis.RedisStoreModule IMPOSTER_STORE_KEY_PREFIX Sets an optional prefix for all keys in the store, like a namespace. A prefix of foo would result in the key bar being stored as foo.bar","title":"Environment variables"},{"location":"stores/#request-scoped-store","text":"There is a special request-scoped store, named request , which is accessible only to the current request. Its contents do not persist beyond the lifecycle of the request. The request scoped store is very useful when you need to capture an item for immediate use, such as in a response template , but you don't need to persist it for later use.","title":"Request scoped store"},{"location":"stores/#preloading-pre-populating-data-into-a-store","text":"You can preload data into a store when Imposter starts. To do this, use the system.stores.preloadFile or system.stores.preloadData key in a configuration file.","title":"Preloading (pre-populating) data into a store"},{"location":"stores/#preloading-from-file","text":"Typically, you will provide the data in a JSON file, and use the preloadFile key: plugin: rest system: stores: # this store is preloaded from file example: preloadFile: initial-data.json In the above example, the contents of the file initial-data.json will be loaded into the store named 'example'. This file contains a JSON object, such as the following: { \"foo\": \"bar\", \"baz\": { \"qux\": \"corge\" } } Note that you can store child objects, but the top level keys must always be a string.","title":"Preloading from file"},{"location":"stores/#preloading-from-inline-data","text":"If you have a small amount of data, or you don't want to use a separate file, you can provide the preload data inline within a configuration file using the preloadData key: plugin: rest system: stores: # this store is preloaded from inline data example: preloadData: foo: bar baz: { \"qux\": \"corge\" } In the above example, the items under preloadData block will be loaded into the store named 'example'. You must provide an object with key/value pairs, such as that shown above, or in the JSON file below. Top level keys must always be a string.","title":"Preloading from inline data"},{"location":"stores/#store-implementations","text":"Different store implementations exist: In memory store (default) Redis store","title":"Store implementations"},{"location":"templates/","text":"Response templates Imposter allows you to respond with a template - that is, a file containing placeholders, which are replaced with values at runtime. Templates can be useful when you are capturing data , using stores or generating data from a script . Templates can be used with configuration or scripts. Configuration-driven templates When you are using configuration files to control mock behaviour, you can use the template: true property of the response object, as follows: resources: - path: /example method: GET response: staticFile: example-template.json template: true In this example, the template file ('example-template.json') might look like this: { \"userName\": \"${testStore.user}\" } Notice the placeholder: ${testStore.user} - this refers to an item named 'user' in the store named 'testStore'. Learn more about stores . A common pattern is to capture elements of the request into a store and use them in a templated response. Script-driven templates When you are using scripting to control mock behaviour, you can use the template() method, as follows: respond().withFile('example-template.json').template(); As with the configuration-driven approach described above, your template includes placeholders referring to data items in a store. Learn more about stores . A common pattern would be to retrieve items from a store using a script, or generate values dynamically and set them in the request store, for use by a template. Using JsonPath in placeholders You can use a JsonPath expression to query a complex object in a placeholder. This is useful if you have stored/captured an object, such as from a request body, and wish to use some part of the object instead of the whole object in a template. The syntax is as follows: ${STORE_NAME.ITEM_NAME:JSONPATH_EXPRESSION} For example: ${request.person:$.name} In this example, there is quite a lot going on. First, the item named person is retrieved from the request store. Remember that when capturing data from the request, you specify the name of the item (in this case, 'person') and the source of the data. Our request body looks like this: { \"name\": \"Alice\", \"occupation\": \"Programmer\" } The corresponding capture configuration is as follows: # part of your configuration file resources: - path: \"/users\" method: POST capture: person: jsonPath: $ Note that $ indicates the whole request body object should be captured into the person item. Since the person item is an object, we can use JsonPath to query the name property - hence the expression $.name in the template placeholder. Similarly, you could refer to other properties of the item - occupation would look like this: Your occupation is: ${request.person:$.occupation} Templating performance Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required. Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests. Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution. Examples response-template","title":"Response templates"},{"location":"templates/#response-templates","text":"Imposter allows you to respond with a template - that is, a file containing placeholders, which are replaced with values at runtime. Templates can be useful when you are capturing data , using stores or generating data from a script . Templates can be used with configuration or scripts.","title":"Response templates"},{"location":"templates/#configuration-driven-templates","text":"When you are using configuration files to control mock behaviour, you can use the template: true property of the response object, as follows: resources: - path: /example method: GET response: staticFile: example-template.json template: true In this example, the template file ('example-template.json') might look like this: { \"userName\": \"${testStore.user}\" } Notice the placeholder: ${testStore.user} - this refers to an item named 'user' in the store named 'testStore'. Learn more about stores . A common pattern is to capture elements of the request into a store and use them in a templated response.","title":"Configuration-driven templates"},{"location":"templates/#script-driven-templates","text":"When you are using scripting to control mock behaviour, you can use the template() method, as follows: respond().withFile('example-template.json').template(); As with the configuration-driven approach described above, your template includes placeholders referring to data items in a store. Learn more about stores . A common pattern would be to retrieve items from a store using a script, or generate values dynamically and set them in the request store, for use by a template.","title":"Script-driven templates"},{"location":"templates/#using-jsonpath-in-placeholders","text":"You can use a JsonPath expression to query a complex object in a placeholder. This is useful if you have stored/captured an object, such as from a request body, and wish to use some part of the object instead of the whole object in a template. The syntax is as follows: ${STORE_NAME.ITEM_NAME:JSONPATH_EXPRESSION} For example: ${request.person:$.name} In this example, there is quite a lot going on. First, the item named person is retrieved from the request store. Remember that when capturing data from the request, you specify the name of the item (in this case, 'person') and the source of the data. Our request body looks like this: { \"name\": \"Alice\", \"occupation\": \"Programmer\" } The corresponding capture configuration is as follows: # part of your configuration file resources: - path: \"/users\" method: POST capture: person: jsonPath: $ Note that $ indicates the whole request body object should be captured into the person item. Since the person item is an object, we can use JsonPath to query the name property - hence the expression $.name in the template placeholder. Similarly, you could refer to other properties of the item - occupation would look like this: Your occupation is: ${request.person:$.occupation}","title":"Using JsonPath in placeholders"},{"location":"templates/#templating-performance","text":"Templating incurs a performance penalty, but is often faster than dynamically generating large objects using scripts, so is generally a better tradeoff when dynamic responses are required. Template files are cached in memory once read from disk, so they do not incur as high an I/O cost from storage on subsequent requests. Using JsonPath in placeholder templates is computationally expensive, as it requires parsing and querying of an item rather than just value substitution.","title":"Templating performance"},{"location":"templates/#examples","text":"response-template","title":"Examples"},{"location":"tips_tricks/","text":"Tips and tricks This section provides more ideas on how to use Imposter as part of your project. Waiting for the server to be ready The mock server exposes an endpoint at /system/status that will return HTTP 200 when the mock server is up and running. You can use this in your tests to know when the mock server is ready. Script logging You can use the logger object within your scripts, which supports levels such as info , debug etc. Standalone mocks You can make use of Imposter mocks as standalone Docker containers. Here's a simple overview: Create a simple Dockerfile that extends outofcoffee/imposter and adds your desired properties as its CMD . Add your mock configuration and mock data to /opt/imposter/config within the Docker image. Build an image from your Dockerfile . Now, when you start a container from your image, your standalone mock container will start, load your configuration and mock data, and listen for connections. JUnit integration You can make use of Imposter mocks in your JUnit tests using the excellent testcontainers library. This will enable your mocks to start/stop before/after your tests run. Here's a simple overview: Follow the testcontainers 'getting started' documentation for your project. Add your mock configuration and mock data to your project (e.g. under src/test/resources ). Add a testcontainers GenericContainer class rule to your JUnit test, for one of the Imposter Docker images (see Docker section). Configure your GenericContainer to mount the directory containing your configuration and data (e.g. src/test/resources ) to /opt/imposter/config . Configure your GenericContainer to wait for the /system/status HTTP endpoint to be accessible so your tests don't start before the mock is ready. Now, when you run your test, your custom mock container will start, load your configuration and mock data, ready for your test methods to use it!","title":"Tips and tricks"},{"location":"tips_tricks/#tips-and-tricks","text":"This section provides more ideas on how to use Imposter as part of your project.","title":"Tips and tricks"},{"location":"tips_tricks/#waiting-for-the-server-to-be-ready","text":"The mock server exposes an endpoint at /system/status that will return HTTP 200 when the mock server is up and running. You can use this in your tests to know when the mock server is ready.","title":"Waiting for the server to be ready"},{"location":"tips_tricks/#script-logging","text":"You can use the logger object within your scripts, which supports levels such as info , debug etc.","title":"Script logging"},{"location":"tips_tricks/#standalone-mocks","text":"You can make use of Imposter mocks as standalone Docker containers. Here's a simple overview: Create a simple Dockerfile that extends outofcoffee/imposter and adds your desired properties as its CMD . Add your mock configuration and mock data to /opt/imposter/config within the Docker image. Build an image from your Dockerfile . Now, when you start a container from your image, your standalone mock container will start, load your configuration and mock data, and listen for connections.","title":"Standalone mocks"},{"location":"tips_tricks/#junit-integration","text":"You can make use of Imposter mocks in your JUnit tests using the excellent testcontainers library. This will enable your mocks to start/stop before/after your tests run. Here's a simple overview: Follow the testcontainers 'getting started' documentation for your project. Add your mock configuration and mock data to your project (e.g. under src/test/resources ). Add a testcontainers GenericContainer class rule to your JUnit test, for one of the Imposter Docker images (see Docker section). Configure your GenericContainer to mount the directory containing your configuration and data (e.g. src/test/resources ) to /opt/imposter/config . Configure your GenericContainer to wait for the /system/status HTTP endpoint to be accessible so your tests don't start before the mock is ready. Now, when you run your test, your custom mock container will start, load your configuration and mock data, ready for your test methods to use it!","title":"JUnit integration"},{"location":"tls_ssl/","text":"TLS/SSL You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options. Note: unless you explicitly override the listen port ( --listenPort ), enabling TLS will change the listen port to 8443. Example java -jar distro/all/build/libs/imposter-all.jar \\ --plugin rest \\ --configDir /path/to/config \\ --tlsEnabled \\ --keystorePath ./server/src/main/resources/keystore/ssl.jks \\ --keystorePassword password Note: This example uses the self-signed certificate for TLS/SSL found in the source repository. You can, of course, use your own keystore instead. If you need to access the keys or certificate from this example, the keystore is located at server/src/main/resources/keystore and uses the secure password 'password'. A note on certificates SSL certificates must match the domain where you\u2019re hosting an application, e.g. https://example.com would need a certificate issued for the example.com domain. Normally, you would obtain a signed certificate for a given domain via a third party provider. Certificates signed by a public certificate authority (CA) will generally be trusted by client applications as the CA is trusted by your system. If you generate a certificate yourself, or use the test one in this project, this is known as a self-signed certificate. Self-signed certificates are untrusted and you usually have to configure your client to accept them explicitly, such as via a trust store or other JVM-wide SSL configuration.","title":"TLS/SSL"},{"location":"tls_ssl/#tlsssl","text":"You can run Imposter with HTTPS enabled. To do this, enable the TLS option and provide keystore options. Note: unless you explicitly override the listen port ( --listenPort ), enabling TLS will change the listen port to 8443.","title":"TLS/SSL"},{"location":"tls_ssl/#example","text":"java -jar distro/all/build/libs/imposter-all.jar \\ --plugin rest \\ --configDir /path/to/config \\ --tlsEnabled \\ --keystorePath ./server/src/main/resources/keystore/ssl.jks \\ --keystorePassword password Note: This example uses the self-signed certificate for TLS/SSL found in the source repository. You can, of course, use your own keystore instead. If you need to access the keys or certificate from this example, the keystore is located at server/src/main/resources/keystore and uses the secure password 'password'.","title":"Example"},{"location":"tls_ssl/#a-note-on-certificates","text":"SSL certificates must match the domain where you\u2019re hosting an application, e.g. https://example.com would need a certificate issued for the example.com domain. Normally, you would obtain a signed certificate for a given domain via a third party provider. Certificates signed by a public certificate authority (CA) will generally be trusted by client applications as the CA is trusted by your system. If you generate a certificate yourself, or use the test one in this project, this is known as a self-signed certificate. Self-signed certificates are untrusted and you usually have to configure your client to accept them explicitly, such as via a trust store or other JVM-wide SSL configuration.","title":"A note on certificates"},{"location":"usage/","text":"Usage (command line arguments and environment variables) Some options can be controlled using command line arguments. These are described in this section. Command line arguments The following command line arguments can be used: --configDir (-c) VAL : Directory containing mock configuration files --help (-h) : Display usage only --host (-b) VAL : Bind host --keystorePassword VAL : Password for the keystore (default: password) --keystorePath VAL : Path to the keystore (default: classpath:/keystore/ssl.jks) --listenPort (-l) N : Listen port (default: 8080) --plugin (-p) VAL : Plugin name (e.g. rest) or fully qualified class --pluginArg VAL : A plugin argument (key=value) --serverUrl (-u) VAL : Explicitly set the server address --tlsEnabled (-t) : Whether TLS (HTTPS) is enabled (requires keystore to be configured) (default: false) --version (-v) : Print version and exit Environment variables The following environment variables are supported: Variable name Purpose Default Description/example(s) IMPOSTER_LOG_LEVEL Sets logging level. DEBUG INFO , DEBUG , TRACE IMPOSTER_FEATURES Enables or disables features. See Features documentation. Per default features . metrics=false,stores=true IMPOSTER_NORMALISE_HEADER_KEYS Forces header keys to be lowercased. false boolean IMPOSTER_STORE_MODULE Sets the store implementation. io.gatehill.imposter.store.inmem.InMemoryStoreModule See Stores . IMPOSTER_STORE_KEY_PREFIX Sets a prefix for store keys. Empty See Stores . IMPOSTER_SCRIPT_CACHE_ENTRIES The number of precompiled scripts to cache. Precompiled scripts execute faster, but the cache uses memory. 20 30 IMPOSTER_RESPONSE_FILE_CACHE_ENTRIES The number of response files to cache in memory. Cached response files don't require disk I/O, but the cache uses memory. 20 30 IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR The default behaviour for OpenAPI validation issues. See OpenAPI validation . IGNORE See OpenAPI validation . Note: other features may include their own environment variables. See the feature specific documentation for more details. Server URL For some responses, such as from the SFDC plugin , Imposter uses the 'server URL', which is computed automatically from the host and listenPort command line arguments. If this is not the URL you wish to use, you can override this with the serverUrl command line argument. Security See Security .","title":"Usage (arguments and environment variables)"},{"location":"usage/#usage-command-line-arguments-and-environment-variables","text":"Some options can be controlled using command line arguments. These are described in this section.","title":"Usage (command line arguments and environment variables)"},{"location":"usage/#command-line-arguments","text":"The following command line arguments can be used: --configDir (-c) VAL : Directory containing mock configuration files --help (-h) : Display usage only --host (-b) VAL : Bind host --keystorePassword VAL : Password for the keystore (default: password) --keystorePath VAL : Path to the keystore (default: classpath:/keystore/ssl.jks) --listenPort (-l) N : Listen port (default: 8080) --plugin (-p) VAL : Plugin name (e.g. rest) or fully qualified class --pluginArg VAL : A plugin argument (key=value) --serverUrl (-u) VAL : Explicitly set the server address --tlsEnabled (-t) : Whether TLS (HTTPS) is enabled (requires keystore to be configured) (default: false) --version (-v) : Print version and exit","title":"Command line arguments"},{"location":"usage/#environment-variables","text":"The following environment variables are supported: Variable name Purpose Default Description/example(s) IMPOSTER_LOG_LEVEL Sets logging level. DEBUG INFO , DEBUG , TRACE IMPOSTER_FEATURES Enables or disables features. See Features documentation. Per default features . metrics=false,stores=true IMPOSTER_NORMALISE_HEADER_KEYS Forces header keys to be lowercased. false boolean IMPOSTER_STORE_MODULE Sets the store implementation. io.gatehill.imposter.store.inmem.InMemoryStoreModule See Stores . IMPOSTER_STORE_KEY_PREFIX Sets a prefix for store keys. Empty See Stores . IMPOSTER_SCRIPT_CACHE_ENTRIES The number of precompiled scripts to cache. Precompiled scripts execute faster, but the cache uses memory. 20 30 IMPOSTER_RESPONSE_FILE_CACHE_ENTRIES The number of response files to cache in memory. Cached response files don't require disk I/O, but the cache uses memory. 20 30 IMPOSTER_OPENAPI_VALIDATION_DEFAULT_BEHAVIOUR The default behaviour for OpenAPI validation issues. See OpenAPI validation . IGNORE See OpenAPI validation . Note: other features may include their own environment variables. See the feature specific documentation for more details.","title":"Environment variables"},{"location":"usage/#server-url","text":"For some responses, such as from the SFDC plugin , Imposter uses the 'server URL', which is computed automatically from the host and listenPort command line arguments. If this is not the URL you wish to use, you can override this with the serverUrl command line argument.","title":"Server URL"},{"location":"usage/#security","text":"See Security .","title":"Security"},{"location":"examples/metrics/","text":"Prometheus metrics for Imposter A worked example of using Prometheus to scrape metrics from an Imposter instance. Prerequisites Docker Steps Start Prometheus using the configuration in this directory: docker run --rm -it -p9090:9090 -v $PWD/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus (Optional) start Grafana: docker run --rm -it -p3000:3000 -v $PWD/grafana.yml:/etc/grafana/provisioning/datasources/imposter.yml grafana/grafana Example You can use the Docker Compose file in this directory to quickly stand up Prometheus and Grafana.","title":"Prometheus metrics for Imposter"},{"location":"examples/metrics/#prometheus-metrics-for-imposter","text":"A worked example of using Prometheus to scrape metrics from an Imposter instance.","title":"Prometheus metrics for Imposter"},{"location":"examples/metrics/#prerequisites","text":"Docker","title":"Prerequisites"},{"location":"examples/metrics/#steps","text":"Start Prometheus using the configuration in this directory: docker run --rm -it -p9090:9090 -v $PWD/prometheus.yml:/etc/prometheus/prometheus.yml prom/prometheus (Optional) start Grafana: docker run --rm -it -p3000:3000 -v $PWD/grafana.yml:/etc/grafana/provisioning/datasources/imposter.yml grafana/grafana","title":"Steps"},{"location":"examples/metrics/#example","text":"You can use the Docker Compose file in this directory to quickly stand up Prometheus and Grafana.","title":"Example"},{"location":"hack/","text":"Developing Imposter Convenience script The script scripts/dev-current.sh is intended for local testing when changing the Impsoter codebase. The script performs the following steps: builds Imposter from source starts Imposter using Docker or plain JVM enables a specified plugin passes the specified directory as the configuration directory Usage: dev-current.sh [args] Arguments: -m <docker|java> How to run Imposter, e.g. docker [-p plugin-name] The plugin name, e.g. openapi [-c config-dir] Fully qualified path to the Imposter configuration directory [-l log-level] Logging level, e.g. DEBUG or TRACE [-t run-tests] Whether to run tests (true or false). Default is true Example: $ ./scripts/dev-current.sh -m java -p openapi -c $PWD/docs/examples/openapi/simple This starts Imposter in bare JVM mode (no Docker) with the OpenAPI plugin enabled, pointing to the examples directory. Debugging When started using this script, JVM debug mode is enabled and the debug socket is opened on port 8000. Test with Gradle You can run a test using a specific JVM version using Docker and Gradle as follows: docker run -it --rm -u gradle -v \"$PWD\":/home/gradle/project -w /home/gradle/project amd64/gradle:5.6-jdk8 gradle clean test","title":"Developing Imposter"},{"location":"hack/#developing-imposter","text":"","title":"Developing Imposter"},{"location":"hack/#convenience-script","text":"The script scripts/dev-current.sh is intended for local testing when changing the Impsoter codebase. The script performs the following steps: builds Imposter from source starts Imposter using Docker or plain JVM enables a specified plugin passes the specified directory as the configuration directory Usage: dev-current.sh [args] Arguments: -m <docker|java> How to run Imposter, e.g. docker [-p plugin-name] The plugin name, e.g. openapi [-c config-dir] Fully qualified path to the Imposter configuration directory [-l log-level] Logging level, e.g. DEBUG or TRACE [-t run-tests] Whether to run tests (true or false). Default is true Example: $ ./scripts/dev-current.sh -m java -p openapi -c $PWD/docs/examples/openapi/simple This starts Imposter in bare JVM mode (no Docker) with the OpenAPI plugin enabled, pointing to the examples directory.","title":"Convenience script"},{"location":"hack/#debugging","text":"When started using this script, JVM debug mode is enabled and the debug socket is opened on port 8000.","title":"Debugging"},{"location":"hack/#test-with-gradle","text":"You can run a test using a specific JVM version using Docker and Gradle as follows: docker run -it --rm -u gradle -v \"$PWD\":/home/gradle/project -w /home/gradle/project amd64/gradle:5.6-jdk8 gradle clean test","title":"Test with Gradle"}]}